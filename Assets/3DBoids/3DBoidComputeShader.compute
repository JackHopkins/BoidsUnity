// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

#define QUATERNION_IDENTITY float4(0, 0, 0, 1)
#define PI 3.14159265359f

struct Boid 
{
    float3 pos;
    float3 vel;
    float4 rot;
    float pad0;
    float pad1;
};

RWStructuredBuffer<Boid> boidBuffer;
uniform int numBoids;
uniform float deltaTime;
uniform float maxSpeed;
uniform float minSpeed;
uniform float edgeMargin;
uniform float visualRange;
uniform float cohesionFactor;
uniform float seperationFactor;
uniform float alignmentFactor;
uniform float minDistance;
uniform float turnSpeed;
uniform float xBound;
uniform float yBound;
uniform float zBound;

StructuredBuffer<uint2> gridIndicesBuffer;
float gridCellSize;
int gridRows;
int gridCols;
int gridDepth;

uint3 getGridLocation(Boid boid) {
	int boidX = floor(boid.pos.x / gridCellSize + (uint)gridCols/2);
    int boidY = floor(boid.pos.y / gridCellSize + (uint)gridRows/2);
    int boidZ = floor(boid.pos.z / gridCellSize + (uint)gridDepth/2);
    return uint3(boidX, boidY, boidZ);
}

uint getGridID(uint3 pos) {
    return (gridRows * gridCols * pos.z) + (gridCols * pos.y) + pos.x;
}

void MergedBehaviours(inout Boid boid) {
    float3 center = 0;
    float3 close = 0;
    float3 avgVel = 0;
    int neighbours = 0;

    int3 gridXYZ = getGridLocation(boid);

    for (int z = gridXYZ.z - 1; z <= gridXYZ.z + 1; z++) {
        for (int y = gridXYZ.y - 1; y <= gridXYZ.y + 1; y++) {
            for (int x = gridXYZ.x - 1; x <= gridXYZ.x + 1; x++) {
                uint cell = getGridID(uint3(x,y,z));
                uint2 cellIndices = gridIndicesBuffer[cell];

                for (uint i = cellIndices.x; i < cellIndices.y; i++) {
                    Boid other = boidBuffer[i];

                    float dist = distance(boid.pos, other.pos);
                    if(dist < visualRange) {
                        if(dist < minDistance) {
                            close += boid.pos - other.pos;
                        }
                        center += other.pos;
                        avgVel += other.vel;
                        neighbours++;
                    }
                }
            }
        }
    }

    if (neighbours > 0) {
        center /= neighbours;
        avgVel /= neighbours;

        boid.vel += (center - boid.pos) * cohesionFactor * deltaTime;
        boid.vel += (avgVel - boid.vel) * alignmentFactor * deltaTime;
    }

    boid.vel += close * seperationFactor * deltaTime;

}

void LimitSpeed(inout Boid boid) {
    float speed = length(boid.vel);
    if(speed > maxSpeed) {
        boid.vel = normalize(boid.vel) * maxSpeed;
    } else if (speed < minSpeed) {
        boid.vel = normalize(boid.vel) * minSpeed;
    }
}

void KeepInBounds(inout Boid boid) {
    if (boid.pos.x < -xBound) {
      boid.vel.x += deltaTime * turnSpeed;
    } else if (boid.pos.x > xBound) {
      boid.vel.x -= deltaTime * turnSpeed;
    }

    if (boid.pos.y > yBound) {
      boid.vel.y -= deltaTime * turnSpeed;
    } else if (boid.pos.y < -yBound) {
      boid.vel.y += deltaTime * turnSpeed;
    }

    if (boid.pos.z > zBound) {
      boid.vel.z -= deltaTime * turnSpeed;
    } else if (boid.pos.z < -zBound) {
      boid.vel.z += deltaTime * turnSpeed;
    }
}

[numthreads(64,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    Boid boid = boidBuffer[id.x];
    
    MergedBehaviours(boid);
    LimitSpeed(boid);
    KeepInBounds(boid);

    // Update positions and rotation
    boid.pos += boid.vel * deltaTime;

    // Convert direction to quaternion
    float4 q;
    q.xyz = cross(float3(0,1,0), boid.vel);
    q.w = sqrt((pow(length(float3(0,1,0)),2)) * (pow(length(boid.vel),2))) + dot(float3(0,1,0), boid.vel);
    boid.rot = normalize(q);

    boidBuffer[id.x] = boid;
}


