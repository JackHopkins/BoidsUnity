// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

#define QUATERNION_IDENTITY float4(0, 0, 0, 1)
#define PI 3.14159265359f

struct Boid 
{
    float3 pos;
    float3 vel;
    float4 rot;
    float pad0;
    float pad1;
};

RWStructuredBuffer<Boid> boidBuffer;
uniform int numBoids;
uniform float deltaTime;
uniform float maxSpeed;
uniform float minSpeed;
uniform float edgeMargin;
uniform float visualRange;
uniform float cohesionFactor;
uniform float seperationFactor;
uniform float alignmentFactor;
uniform float minDistance;
uniform float turnSpeed;
uniform float xBound;
uniform float yBound;
uniform float zBound;

StructuredBuffer<int2> gridBuffer;
StructuredBuffer<uint2> gridIndicesBuffer;
float gridCellSize;
int gridRows;
int gridCols;
int gridDepth;

uint3 getGridLocation(Boid boid) {
	  int boidX = floor(boid.pos.x / gridCellSize + (uint)gridCols/2);
    int boidY = floor(boid.pos.y / gridCellSize + (uint)gridRows/2);
    int boidZ = floor(boid.pos.z / gridCellSize + (uint)gridDepth/2);
    return uint3(boidX, boidY, boidZ);
}

uint getGridID(uint3 pos) {
    return (gridRows * gridCols * pos.z) + (gridCols * pos.y) + pos.x;
}

void MergedBehaviours(inout Boid boid) {
    float3 center = 0;
    float3 close = 0;
    float3 avgVel = 0;
    int neighbours = 0;

    int3 G_XYZ = getGridLocation(boid);

    for (int Z = max(G_XYZ.z - 1, 0); Z <= G_XYZ.z + 1; Z++) {
        for (int Y = max(G_XYZ.y - 1, 0); Y <= G_XYZ.y + 1; Y++) {
            for (int X = max(G_XYZ.x - 1, 0); X <= G_XYZ.x + 1; X++) {
                uint G_CELL = getGridID(uint3(X,Y,Z));
                uint2 G_START_END = gridIndicesBuffer[G_CELL];

                for (uint N_ID = G_START_END.x; N_ID < G_START_END.y; N_ID++) {
                    int boidIndex = gridBuffer[N_ID].y;
                    Boid other = boidBuffer[boidIndex];

                    float dist = distance(boid.pos, other.pos);
                    if(dist < visualRange) {
                        if(dist < minDistance) {
                            close += boid.pos - other.pos;
                        }
                        center += other.pos;
                        avgVel += other.vel;
                        neighbours++;
                    }
                }
            }
        }
    }

    if (neighbours > 0) {
        center /= neighbours;
        avgVel /= neighbours;

        boid.vel += (center - boid.pos) * cohesionFactor * deltaTime;
        boid.vel += (avgVel - boid.vel) * alignmentFactor * deltaTime;
    }

    boid.vel += close * seperationFactor * deltaTime;

}

void LimitSpeed(inout Boid boid) {
    float speed = length(boid.vel);
    if(speed > maxSpeed) {
        boid.vel = normalize(boid.vel) * maxSpeed;
    } else if (speed < minSpeed) {
        boid.vel = normalize(boid.vel) * minSpeed;
    }
}

void KeepInBounds(inout Boid boid) {
    if (boid.pos.x < -xBound) {
      boid.vel.x += deltaTime * turnSpeed;
    } else if (boid.pos.x > xBound) {
      boid.vel.x -= deltaTime * turnSpeed;
    }

    if (boid.pos.y > yBound) {
      boid.vel.y -= deltaTime * turnSpeed;
    } else if (boid.pos.y < -yBound) {
      boid.vel.y += deltaTime * turnSpeed;
    }

    if (boid.pos.z > zBound) {
      boid.vel.z -= deltaTime * turnSpeed;
    } else if (boid.pos.z < -zBound) {
      boid.vel.z += deltaTime * turnSpeed;
    }
}

[numthreads(64,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    Boid boid = boidBuffer[id.x];
    
    MergedBehaviours(boid);
    LimitSpeed(boid);
    KeepInBounds(boid);

    // Update positions and rotation
    boid.pos += boid.vel * deltaTime;

    // Convert direction to quaternion
    float4 q;
    q.xyz = cross(float3(0,1,0), boid.vel);
    q.w = sqrt((pow(length(float3(0,1,0)),2)) * (pow(length(boid.vel),2))) + dot(float3(0,1,0), boid.vel);
    boid.rot = normalize(q);

    boidBuffer[id.x] = boid;
}


