#define blockSize 1024

struct Boid {
  float2 pos;
  float2 vel;
  uint team;
};

struct Obstacle {
  float2 pos;
  float radius;
  float strength;
};

StructuredBuffer<Obstacle> obstacles;
uniform uint numObstacles;
uniform float obstacleAvoidanceWeight;


StructuredBuffer<Boid> boidsIn;
RWStructuredBuffer<Boid> boidsOut;
uniform uint numBoids;
uniform float deltaTime;
uniform float maxSpeed;
uniform float minSpeed;
uniform float edgeMargin;
uniform float visualRangeSq;
uniform float cohesionFactor;
uniform float separationFactor;
uniform float alignmentFactor;
uniform float minDistanceSq;
uniform float turnSpeed;
uniform float xBound;
uniform float yBound;

uniform float teamRatio;
uniform float intraTeamCohesionMultiplier;
uniform float interTeamRepulsionMultiplier;


StructuredBuffer<uint> gridOffsetBuffer;
float gridCellSize;
uint gridDimY;
uint gridDimX;

uint2 getGridLocation(Boid boid) {
  int x = floor(boid.pos.x / gridCellSize + gridDimX / 2);
  int y = floor(boid.pos.y / gridCellSize + gridDimY / 2);
  return uint2(x, y);
}

uint getGridID(uint2 pos) {
  return (gridDimX * pos.y) + pos.x;
}


float2 CalculateObstacleAvoidance(float2 position) {
  float2 avoidanceForce = float2(0, 0);
  
  for (uint i = 0; i < numObstacles; i++) {
    float2 diff = position - obstacles[i].pos;
    float distance = length(diff);
    
    if (distance < obstacles[i].radius) {
      // Normalize and scale the force inversely with distance
      float2 direction = normalize(diff);
      float force = obstacles[i].strength * (1.0 - (distance / obstacles[i].radius));
      avoidanceForce += direction * force;
    }
  }
  
  return avoidanceForce;
}


void MergedBehaviours(inout Boid boid) {
  float2 center = 0;
  float2 close = 0;
  float2 avgVel = 0;
  uint sameTeamNeighbours = 0;
  uint otherTeamNeighbours = 0;

  uint2 gridXY = getGridLocation(boid);
  uint cell = getGridID(gridXY);
  
  // Loop Around Own Cell
  for (uint y = cell - gridDimX; y <= cell + gridDimX; y += gridDimX) {
    uint start = gridOffsetBuffer[y - 2];
    uint end = gridOffsetBuffer[y + 1];
    
    for (uint i = start; i < end; i++) {
      Boid other = boidsIn[i];
      float2 diff = boid.pos - other.pos;
      float distSq = dot(diff, diff);
      
      if (distSq < visualRangeSq && distSq > 0) {
        // Check if same team
        bool sameTeam = boid.team == other.team;
        
        // Apply stronger separation for other team
        if (distSq < minDistanceSq) {
		  
          float repulsionStrength = 1.0f;//sameTeam ? 1.0 : interTeamRepulsionMultiplier;
          float invDistSq = 1.0 / distSq;
          close += diff * invDistSq * repulsionStrength;
        }
        
        // Only apply cohesion and alignment with same team
        if (sameTeam) {
          center += other.pos;
          avgVel += other.vel;
          sameTeamNeighbours++;
        } else {
          otherTeamNeighbours++;
        }
      }
    }
  }
  
  // Apply cohesion and alignment only with same team members
  if (sameTeamNeighbours > 0) {
    center /= sameTeamNeighbours;
    avgVel /= sameTeamNeighbours;
    
    // Apply stronger cohesion within team
    boid.vel += (center - boid.pos) * (cohesionFactor * intraTeamCohesionMultiplier * deltaTime);
    boid.vel += (avgVel - boid.vel) * (alignmentFactor * deltaTime);
  }
  
  boid.vel += close * (separationFactor * deltaTime);
  
  float2 obstacleForce = CalculateObstacleAvoidance(boid.pos);
  boid.vel += obstacleForce * obstacleAvoidanceWeight * deltaTime;
}


void LimitSpeed(inout Boid boid) {
  float speed = length(boid.vel);
  float clampedSpeed = clamp(speed, minSpeed, maxSpeed);
  boid.vel *= clampedSpeed / speed;
}

void KeepInBounds(inout Boid boid) {
  if (abs(boid.pos.x) > xBound) {
    boid.vel.x -= sign(boid.pos.x) * deltaTime * turnSpeed;
  }
  if (abs(boid.pos.y) > yBound) {
    boid.vel.y -= sign(boid.pos.y) * deltaTime * turnSpeed;
  }
}

#pragma kernel UpdateBoids // ID 0
[numthreads(blockSize, 1, 1)]
void UpdateBoids(uint3 id : SV_DispatchThreadID) {
  if (id.x >= numBoids) {
    return;
  }
  
  Boid boid = boidsIn[id.x];
  
  MergedBehaviours(boid);
  LimitSpeed(boid);
  KeepInBounds(boid);

  // Update positions
  boid.pos += boid.vel * deltaTime;
  boidsOut[id.x] = boid;
}


// Basic random generation
uint randSeed;
uint rngState;
float randPCG(float min, float max) {
  rngState = rngState * 747796405u + 2891336453u;
  uint state = rngState;
  uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;
  float f = ((word >> 22u) ^ word) / 4294967296.0;
  return f * (max - min) + min;
}


#pragma kernel GenerateBoids // ID 1
[numthreads(blockSize, 1, 1)]
void GenerateBoids(uint3 id : SV_DispatchThreadID) {
  rngState = randSeed + id.x;
  boidsOut[id.x].pos = float2(randPCG(-xBound, xBound), randPCG(-yBound, yBound));
  boidsOut[id.x].vel = float2(randPCG(-maxSpeed, maxSpeed), randPCG(-maxSpeed, maxSpeed));
  float threshold = numBoids * teamRatio;
  boidsOut[id.x].team = id.x < threshold ? 0 : 1;
}
