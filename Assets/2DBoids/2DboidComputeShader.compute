// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

struct Boid {
    float2 pos;
    float2 vel;
    float rot;
    float pad0;
    float pad1;
    float pad2;
};

RWStructuredBuffer<Boid> boids;
uniform int numBoids;
uniform float deltaTime;
uniform float maxSpeed;
uniform float minSpeed;
uniform float edgeMargin;
uniform float visualRange;
uniform float cohesionFactor;
uniform float seperationFactor;
uniform float alignmentFactor;
uniform float minDistance;
uniform float turnSpeed;
uniform float xBound;
uniform float yBound;

RWStructuredBuffer<int2> gridBuffer;
RWStructuredBuffer<uint> gridOffsetsBuffer;
float gridCellSize;
int gridRows;
int gridCols;

int getGridID(Boid boid) {
    int boidRow = floor(boid.pos.y / gridCellSize + gridRows);
    int boidCol = floor(boid.pos.x / gridCellSize + gridCols);
    return (gridCols * boidRow) + boidCol;
}

void GetNearby(Boid boid) {
    
}

void MergedBehaviours(inout Boid boid) {
    float2 center = 0;
    float2 close = 0;
    float2 avgVel = 0;
    int neighbours = 0;

    int id = getGridID(boid);
    for(int row = id - gridCols; row <= id + gridCols; row += gridCols) {
        int startOffset = gridOffsetsBuffer[row - 1];
        int endOffset = gridOffsetsBuffer[row + 2];
        for(int i = startOffset; i < endOffset; i++){
            uint boidID = gridBuffer[i].y;
            Boid other = boids[boidID];
            float dist = distance(boid.pos, other.pos);
            if(dist < visualRange) {
                if(dist < minDistance) {
                    close += boid.pos - other.pos;
                }
                center += other.pos;
                avgVel += other.vel;
                neighbours++;
            }
        }
    }

    // for (int i = 0; i < numBoids; i++) {
    //     Boid other = boids[i];
    //     float dist = distance(boid.pos, other.pos);
    //     if(dist < visualRange) {
    //         if(dist < minDistance) {
    //             close += boid.pos - other.pos;
    //         }
    //         center += other.pos;
    //         avgVel += other.vel;
    //         neighbours++;
    //     }
    // }

    if (neighbours > 0) {
        center /= neighbours;
        avgVel /= neighbours;

        boid.vel += (center - boid.pos) * cohesionFactor * deltaTime;
        boid.vel += (avgVel - boid.vel) * alignmentFactor * deltaTime;
    }

    boid.vel += close * seperationFactor * deltaTime;

}

void LimitSpeed(inout Boid boid) {
    float speed = length(boid.vel);
    if(speed > maxSpeed) {
        boid.vel = normalize(boid.vel) * maxSpeed;
    } else if (speed < minSpeed) {
        boid.vel = normalize(boid.vel) * minSpeed;
    }
}

void KeepInBounds(inout Boid boid) {
    if (boid.pos.x < -xBound) {
      boid.vel.x += deltaTime * turnSpeed;
    } else if (boid.pos.x > xBound) {
      boid.vel.x -= deltaTime * turnSpeed;
    }

    if (boid.pos.y > yBound) {
      boid.vel.y -= deltaTime * turnSpeed;
    } else if (boid.pos.y < -yBound) {
      boid.vel.y += deltaTime * turnSpeed;
    }
}

[numthreads(64,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    Boid boid = boids[id.x];
    
    MergedBehaviours(boid);
    LimitSpeed(boid);
    KeepInBounds(boid);

    // Update positions and rotation
    boid.pos += boid.vel * deltaTime;
    boid.rot = atan2(boid.vel.y, boid.vel.x) - 1.5708f;
    boids[id.x] = boid;
}


