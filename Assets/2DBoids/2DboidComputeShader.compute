#define blockSize 1024
#define NODE_LEAF 1
#define NODE_ACTIVE 2

struct Boid {
  float2 pos;
  float2 vel;
  uint team;
};

struct Obstacle {
  float2 pos;
  float radius;
  float strength;
};

struct QuadNode {
  float2 center;
  float size;
  uint childIndex;
  uint startIndex;
  uint count;
  uint flags;
};

StructuredBuffer<Obstacle> obstacles;
StructuredBuffer<Boid> boidsIn;
RWStructuredBuffer<Boid> boidsOut;
StructuredBuffer<QuadNode> quadNodes;
StructuredBuffer<uint> activeNodes;
StructuredBuffer<uint> nodeCount;
StructuredBuffer<uint> boidIndices;

uniform RWStructuredBuffer<uint2> boidNodeAssignment; // Stores node index for each boid
uniform uint numObstacles;
uniform float obstacleAvoidanceWeight;
uniform int useQuadTree;
uniform uint numBoids;
uniform float deltaTime;
uniform float maxSpeed;
uniform float minSpeed;
uniform float edgeMargin;
uniform float visualRangeSq;
uniform float cohesionFactor;
uniform float separationFactor;
uniform float alignmentFactor;
uniform float minDistanceSq;
uniform float turnSpeed;
uniform float xBound;
uniform float yBound;

uniform float teamRatio;
uniform float intraTeamCohesionMultiplier;
uniform float interTeamRepulsionMultiplier;


StructuredBuffer<uint> gridOffsetBuffer;
float gridCellSize;
uint gridDimY;
uint gridDimX;

uint2 getGridLocation(Boid boid) {
  int x = floor(boid.pos.x / gridCellSize + gridDimX / 2);
  int y = floor(boid.pos.y / gridCellSize + gridDimY / 2);
  return uint2(x, y);
}

uint getGridID(uint2 pos) {
  return (gridDimX * pos.y) + pos.x;
}

// Improved quadtree neighbor search
void FindNearbyBoidsQuadTree(float2 position, float radiusSq, inout float2 center, 
                           inout float2 close, inout float2 avgVel, 
                           inout uint sameTeamNeighbours, inout uint otherTeamNeighbours, 
                           uint boidTeam, uint currentBoidIndex) {
    // Use a stack to avoid recursion
    uint stack[32];
    uint stackSize = 0;
    
    // Start with root node
    stack[stackSize++] = 0;
    
    while (stackSize > 0) {
        // Pop a node from the stack
        uint nodeIndex = stack[--stackSize];
        QuadNode node = quadNodes[nodeIndex];
        
        // Calculate distance from position to nearest point of node's bounding box
        float2 nodeMin = node.center - node.size;
        float2 nodeMax = node.center + node.size;
        
        // Find closest point on node to the boid's position
        float2 closest;
        closest.x = max(nodeMin.x, min(position.x, nodeMax.x));
        closest.y = max(nodeMin.y, min(position.y, nodeMax.y));
        
        // Check distance to closest point
        float2 diff = position - closest;
        float distSq = dot(diff, diff);
        
        // If node is too far, skip it
        if (distSq > radiusSq) {
            continue;
        }
        
        // Process leaf node
        if ((node.flags & NODE_LEAF) != 0) {
            // Check if this node has boids
            if (node.count > 0) {
                // Get the start index for this node's boids
                uint startIdx = node.startIndex;
                uint endIdx = startIdx + node.count;
                
                // Ensure we don't go out of bounds
                endIdx = min(endIdx, numBoids);
                
                // Process all boids in this node
                for (uint i = startIdx; i < endIdx; i++) {
                    // Skip if this is the current boid
                    if (i == currentBoidIndex) continue;
                    
                    Boid other = boidsIn[i];
                    
                    // Calculate distance to other boid
                    float2 boidDiff = position - other.pos;
                    float boidDistSq = dot(boidDiff, boidDiff);
                    
                    // If within visual range
                    if (boidDistSq > 0 && boidDistSq < radiusSq) {
                        bool sameTeam = boidTeam == other.team;
                        
                        // Apply separation if too close
                        if (boidDistSq < minDistanceSq) {
                            float repulsionStrength = sameTeam ? 1.0 : interTeamRepulsionMultiplier;
                            float invDistSq = 1.0 / max(boidDistSq, 0.0001); // Avoid division by zero
                            close += boidDiff * invDistSq * repulsionStrength;
                        }
                        
                        // Apply cohesion and alignment for same team
                        if (sameTeam) {
                            center += other.pos;
                            avgVel += other.vel;
                            sameTeamNeighbours++;
                        } else {
                            otherTeamNeighbours++;
                        }
                    }
                }
            }
        } 
        // Process internal node (not a leaf)
        else if (node.childIndex > 0) {
            // Add all children to the stack
            for (uint i = 0; i < 4; i++) {
                uint childIndex = node.childIndex + i;
                // Ensure the child index is valid
                if (childIndex < nodeCount[0]) {
                    stack[stackSize++] = childIndex;
                }
            }
        }
    }
}

float2 CalculateObstacleAvoidance(float2 position) {
  float2 avoidanceForce = float2(0, 0);
  
  for (uint i = 0; i < numObstacles; i++) {
    float2 diff = position - obstacles[i].pos;
    float distance = length(diff);
    
    if (distance < obstacles[i].radius) {
      // Normalize and scale the force inversely with distance
      float2 direction = normalize(diff);
      float force = obstacles[i].strength * (1.0 - (distance / obstacles[i].radius));
      avoidanceForce += direction * force;
    }
  }
  
  return avoidanceForce;
}

// Improved cohesion and alignment calculation
void MergedBehaviours(inout Boid boid, uint boidIndex) {
    float2 center = float2(0, 0);
    float2 close = float2(0, 0);
    float2 avgVel = float2(0, 0);
    uint sameTeamNeighbours = 0;
    uint otherTeamNeighbours = 0;

    if (useQuadTree == 1) {
        // Use quad-tree for neighbor finding
        FindNearbyBoidsQuadTree(boid.pos, visualRangeSq, center, close, avgVel, 
                              sameTeamNeighbours, otherTeamNeighbours, boid.team, boidIndex);
    } else {
        // Use existing grid-based approach
        uint2 gridXY = getGridLocation(boid);
        uint cell = getGridID(gridXY);
        
        // Add bounds checking to avoid invalid memory access
        if (cell >= gridDimX * gridDimY || cell < gridDimX * 2) {
            return;
        }
        
        // Existing grid-based code...
        for (uint y = cell - gridDimX; y <= cell + gridDimX; y += gridDimX) {
            // Avoid out-of-bounds access
            if (y < 2 || y >= gridDimX * gridDimY - 1) continue;
            
            uint start = gridOffsetBuffer[y - 2];
            uint end = gridOffsetBuffer[y + 1];
            
            // Ensure start < end to avoid invalid access
            if (start >= end) continue;
            
            for (uint i = start; i < end; i++) {
                // Bounds check
                if (i >= numBoids) continue;
                
                // Skip self
                if (i == boidIndex) continue;
                
                Boid other = boidsIn[i];
                float2 diff = boid.pos - other.pos;
                float distSq = dot(diff, diff);
                
                if (distSq < visualRangeSq && distSq > 0) {
                    bool sameTeam = boid.team == other.team;
                    
                    if (distSq < minDistanceSq) {
                        float repulsionStrength = sameTeam ? 1.0 : interTeamRepulsionMultiplier;
                        float invDistSq = 1.0 / max(distSq, 0.0001); // Avoid division by zero
                        close += diff * invDistSq * repulsionStrength;
                    }
                    
                    if (sameTeam) {
                        center += other.pos;
                        avgVel += other.vel;
                        sameTeamNeighbours++;
                    } else {
                        otherTeamNeighbours++;
                    }
                }
            }
        }
    }
    
    // Apply flocking behaviors with improved handling of edge cases
    if (sameTeamNeighbours > 0) {
        // Calculate average position and velocity
        center /= sameTeamNeighbours;
        avgVel /= sameTeamNeighbours;
        
        // Apply cohesion - steer towards center of mass
        float2 cohesionForce = (center - boid.pos) * (cohesionFactor * intraTeamCohesionMultiplier * deltaTime);
        
        // Apply alignment - steer towards average heading
        float2 alignmentForce = (avgVel - boid.vel) * (alignmentFactor * deltaTime);
        
        // Add forces to boid velocity
        boid.vel += cohesionForce;
        boid.vel += alignmentForce;
    }
    
    // Apply separation - steer away from nearby boids
    if (length(close) > 0.0001) {
        boid.vel += close * (separationFactor * deltaTime);
    }
    
    // Apply obstacle avoidance
    float2 obstacleForce = CalculateObstacleAvoidance(boid.pos);
    if (length(obstacleForce) > 0.0001) {
        boid.vel += obstacleForce * obstacleAvoidanceWeight * deltaTime;
    }
}

void LimitSpeed(inout Boid boid) {
  float speed = length(boid.vel);
  // Avoid division by zero
  if (speed > 0.0001) {
    float clampedSpeed = clamp(speed, minSpeed, maxSpeed);
    boid.vel *= clampedSpeed / speed;
  } else {
    // If speed is near zero, give it a small random velocity
    boid.vel = float2(0.01, 0.01);
  }
}

void KeepInBounds(inout Boid boid) {
  if (abs(boid.pos.x) > xBound) {
    boid.vel.x -= sign(boid.pos.x) * deltaTime * turnSpeed;
  }
  if (abs(boid.pos.y) > yBound) {
    boid.vel.y -= sign(boid.pos.y) * deltaTime * turnSpeed;
  }
}

#pragma kernel UpdateBoids
[numthreads(blockSize, 1, 1)]
void UpdateBoids(uint3 id : SV_DispatchThreadID) {
  if (id.x >= numBoids) {
    return;
  }
  
  Boid boid = boidsIn[id.x];
  
  MergedBehaviours(boid, id.x);
  LimitSpeed(boid);
  KeepInBounds(boid);

  // Update positions
  boid.pos += boid.vel * deltaTime;
  boidsOut[id.x] = boid;
}


// Basic random generation
uint randSeed;
uint rngState;
float randPCG(float min, float max) {
  rngState = rngState * 747796405u + 2891336453u;
  uint state = rngState;
  uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;
  float f = ((word >> 22u) ^ word) / 4294967296.0;
  return f * (max - min) + min;
}


#pragma kernel GenerateBoids
[numthreads(blockSize, 1, 1)]
void GenerateBoids(uint3 id : SV_DispatchThreadID) {
  if (id.x >= numBoids) {
    return;
  }
  
  rngState = randSeed + id.x;
  boidsOut[id.x].pos = float2(randPCG(-xBound, xBound), randPCG(-yBound, yBound));
  boidsOut[id.x].vel = float2(randPCG(-maxSpeed, maxSpeed), randPCG(-maxSpeed, maxSpeed));
  float threshold = numBoids * teamRatio;
  boidsOut[id.x].team = id.x < threshold ? 0 : 1;
}