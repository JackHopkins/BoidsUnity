// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

struct Boid {
    float2 pos;
    float2 vel;
    float rot;
    float pad0;
    float pad1;
    float pad2;
};

RWStructuredBuffer<Boid> boids;
uniform int numBoids;
uniform float deltaTime;
uniform float maxSpeed;
uniform float minSpeed;
uniform float edgeMargin;
uniform float visualRange;
uniform float cohesionFactor;
uniform float seperationFactor;
uniform float alignmentFactor;
uniform float minDistance;
uniform float turnSpeed;
uniform float xBound;
uniform float yBound;

StructuredBuffer<uint2> gridIndicesBuffer;
float gridCellSize;
int gridRows;
int gridCols;

uint2 getGridLocation(Boid boid) {
	int boidRow = floor(boid.pos.y / gridCellSize + (uint)gridRows/2);
    int boidCol = floor(boid.pos.x / gridCellSize + (uint)gridCols/2);
    return uint2(boidCol, boidRow);
}

uint getGridID(uint2 pos) {
    return (gridCols * pos.y) + pos.x;
}

void MergedBehaviours(inout Boid boid) {
    float2 center = 0;
    float2 close = 0;
    float2 avgVel = 0;
    int neighbours = 0;

    int2 G_XY = getGridLocation(boid);

    // Loop Around Own Cell
    for (int Y = max(G_XY.y - 1, 0); Y <= G_XY.y + 1; Y++) {
        for (int X = max(G_XY.x - 1, 0); X <= G_XY.x + 1; X++) {
            uint G_CELL = getGridID(uint2(X,Y));
            uint2 G_START_END = gridIndicesBuffer[G_CELL];
            for (uint N_ID = G_START_END.x; N_ID < G_START_END.y; N_ID++) {
                Boid other = boids[N_ID];
                
                float dist = distance(boid.pos, other.pos);
                if(dist < visualRange) {
                    if(dist < minDistance) {
                        close += boid.pos - other.pos;
                    }
                    center += other.pos;
                    avgVel += other.vel;
                    neighbours++;
                }
            }
        }
    }

    if (neighbours > 0) {
        center /= neighbours;
        avgVel /= neighbours;

        boid.vel += (center - boid.pos) * cohesionFactor * deltaTime;
        boid.vel += (avgVel - boid.vel) * alignmentFactor * deltaTime;
    }

    boid.vel += close * seperationFactor * deltaTime;

}

void LimitSpeed(inout Boid boid) {
    float speed = length(boid.vel);
    if(speed > maxSpeed) {
        boid.vel = normalize(boid.vel) * maxSpeed;
    } else if (speed < minSpeed) {
        boid.vel = normalize(boid.vel) * minSpeed;
    }
}

void KeepInBounds(inout Boid boid) {
    if (boid.pos.x < -xBound) {
      boid.vel.x += deltaTime * turnSpeed;
    } else if (boid.pos.x > xBound) {
      boid.vel.x -= deltaTime * turnSpeed;
    }

    if (boid.pos.y > yBound) {
      boid.vel.y -= deltaTime * turnSpeed;
    } else if (boid.pos.y < -yBound) {
      boid.vel.y += deltaTime * turnSpeed;
    }
}

[numthreads(64,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    Boid boid = boids[id.x];
    
    MergedBehaviours(boid);
    LimitSpeed(boid);
    KeepInBounds(boid);

    // Update positions and rotation
    boid.pos += boid.vel * deltaTime;
    boid.rot = atan2(boid.vel.y, boid.vel.x) - 1.5708f;
    boids[id.x] = boid;
}


