// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

struct Boid {
    float2 pos;
    float2 vel;
    float rot;
    float pad0;
    float pad1;
    float pad2;
};

RWStructuredBuffer<Boid> boids;
uniform int numBoids;
uniform float deltaTime;
uniform float maxSpeed;
uniform float minSpeed;
uniform float edgeMargin;
uniform float visualRange;
uniform float cohesionFactor;
uniform float seperationFactor;
uniform float alignmentFactor;
uniform float minDistance;
uniform float turnSpeed;
uniform float xBound;
uniform float yBound;

StructuredBuffer<uint> gridCountBuffer;
StructuredBuffer<uint> gridOffsetBuffer;
float gridCellSize;
int gridRows;
int gridCols;

uint2 getGridLocation(Boid boid) {
    int x = floor(boid.pos.x / gridCellSize + (uint)gridCols/2);
	int y = floor(boid.pos.y / gridCellSize + (uint)gridRows/2);
    return uint2(x, y);
}

uint getGridID(uint2 pos) {
    return (gridCols * pos.y) + pos.x;
}

void MergedBehaviours(inout Boid boid) {
    float2 center = 0;
    float2 close = 0;
    float2 avgVel = 0;
    int neighbours = 0;

    int2 gridXY = getGridLocation(boid);

    // Loop Around Own Cell
    for (int y = gridXY.y - 1; y <= gridXY.y + 1; y++) {
        for (int x = gridXY.x - 1; x <= gridXY.x + 1; x++) {
            uint cell = getGridID(uint2(x,y));
            uint end = gridOffsetBuffer[cell];
            uint start = end - gridCountBuffer[cell];
            for (uint i = start; i < end; i++) {
                Boid other = boids[i];
                float dist = distance(boid.pos, other.pos);
                if(dist < visualRange) {
                    if(dist < minDistance) {
                        close += boid.pos - other.pos;
                    }
                    center += other.pos;
                    avgVel += other.vel;
                    neighbours++;
                }
            }
        }
    }

    if (neighbours > 0) {
        center /= neighbours;
        avgVel /= neighbours;

        boid.vel += (center - boid.pos) * cohesionFactor * deltaTime;
        boid.vel += (avgVel - boid.vel) * alignmentFactor * deltaTime;
    }

    boid.vel += close * seperationFactor * deltaTime;

}

void LimitSpeed(inout Boid boid) {
    float speed = length(boid.vel);
    if(speed > maxSpeed) {
        boid.vel = normalize(boid.vel) * maxSpeed;
    } else if (speed < minSpeed) {
        boid.vel = normalize(boid.vel) * minSpeed;
    }
}

void KeepInBounds(inout Boid boid) {
    if (boid.pos.x < -xBound) {
      boid.vel.x += deltaTime * turnSpeed;
    } else if (boid.pos.x > xBound) {
      boid.vel.x -= deltaTime * turnSpeed;
    }

    if (boid.pos.y > yBound) {
      boid.vel.y -= deltaTime * turnSpeed;
    } else if (boid.pos.y < -yBound) {
      boid.vel.y += deltaTime * turnSpeed;
    }
}

[numthreads(256,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    Boid boid = boids[id.x];
    
    MergedBehaviours(boid);
    LimitSpeed(boid);
    KeepInBounds(boid);

    // Update positions and rotation
    boid.pos += boid.vel * deltaTime;
    boid.rot = atan2(boid.vel.y, boid.vel.x) - 1.5708f;
    boids[id.x] = boid;
}


