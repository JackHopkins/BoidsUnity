#define blockSize 256 // Thread group size for better occupancy
#define NODE_LEAF 1
#define NODE_ACTIVE 2
#define MaxQuadNodes 16384

//-----------------------------------------------------------------------------
// Data structures
//-----------------------------------------------------------------------------

struct Boid {
  float2 pos;
  float2 vel;
  uint team;
  uint status; // 0 = regular boid, 1 = officer
};

struct Obstacle {
  float2 pos;
  float radius;
  float strength;
};

struct QuadNode {
  float2 center;
  float size;
  uint childIndex;
  uint startIndex;
  uint count;
  uint flags;
};

struct NeighborData {
  float2 centerOfMass;     // For cohesion
  float2 separationForce;  // For separation
  float2 averageVelocity;  // For alignment
  uint sameTeamCount;
  uint otherTeamCount;
};

//-----------------------------------------------------------------------------
// Buffers
//-----------------------------------------------------------------------------

StructuredBuffer<Obstacle> obstacles;
StructuredBuffer<Boid> boidsIn;
RWStructuredBuffer<Boid> boidsOut;
StructuredBuffer<QuadNode> quadNodes;
StructuredBuffer<uint> activeNodes;
StructuredBuffer<uint> nodeCount;
StructuredBuffer<uint> boidIndices;

uniform RWStructuredBuffer<uint2> boidNodeAssignment; // Stores node index for each boid
uniform uint numObstacles;
uniform float obstacleAvoidanceWeight;
uniform int useQuadTree;
uniform uint numBoids;

//-----------------------------------------------------------------------------
// Simulation parameters
//-----------------------------------------------------------------------------

uniform float deltaTime;
// Speed constraints
uniform float maxSpeed;
uniform float minSpeed;
// Boundary parameters
uniform float edgeMargin;
uniform float turnSpeed;
uniform float xBound;
uniform float yBound;
// Flocking parameters
uniform float visualRangeSq;
uniform float cohesionFactor;
uniform float separationFactor;
uniform float alignmentFactor;
uniform float minDistanceSq;
// Team parameters
uniform float teamRatio;
uniform float intraTeamCohesionMultiplier;
uniform float interTeamRepulsionMultiplier;
uniform float officerRatio;

//-----------------------------------------------------------------------------
// Grid parameters
//-----------------------------------------------------------------------------

StructuredBuffer<uint> gridOffsetBuffer;
float gridCellSize;
uint gridDimY;
uint gridDimX;

//-----------------------------------------------------------------------------
// Grid utility functions
//-----------------------------------------------------------------------------

uint2 getGridLocation(Boid boid) {
  int x = floor(boid.pos.x / gridCellSize + gridDimX / 2);
  int y = floor(boid.pos.y / gridCellSize + gridDimY / 2);
  return uint2(x, y);
}

uint getGridID(uint2 pos) {
  return (gridDimX * pos.y) + pos.x;
}

//-----------------------------------------------------------------------------
// Random number generation
//-----------------------------------------------------------------------------

uint randSeed;
uint rngState;

float randPCG(float min, float max) {
  rngState = rngState * 747796405u + 2891336453u;
  uint state = rngState;
  uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;
  float f = ((word >> 22u) ^ word) / 4294967296.0;
  return f * (max - min) + min;
}

//-----------------------------------------------------------------------------
// Neighbor finding functions
//-----------------------------------------------------------------------------

// Process an individual boid for neighbor calculations
void ProcessNeighborBoid(float2 position, uint boidTeam, uint currentBoidIndex, uint otherBoidIndex, inout NeighborData neighbors) {
  // Skip self
  if (otherBoidIndex == currentBoidIndex) return;
  
  Boid other = boidsIn[otherBoidIndex];
  
  // Calculate squared distance between boids
  float2 boidDiff = position - other.pos;
  float boidDistSq = dot(boidDiff, boidDiff);
  
  // Only consider boids within visual range
  if (boidDistSq <= 0.0 || boidDistSq >= visualRangeSq) return;
  
  bool sameTeam = boidTeam == other.team;
  
  // Handle separation
  if (boidDistSq < minDistanceSq) {
    float factor = sameTeam ? 1.0 : interTeamRepulsionMultiplier;
    factor /= max(boidDistSq, 0.0001); // Avoid division by zero
    neighbors.separationForce += boidDiff * factor;
  }
  
  // Handle cohesion and alignment (only for same team)
  if (sameTeam) {
    neighbors.centerOfMass += other.pos;
    neighbors.averageVelocity += other.vel;
    neighbors.sameTeamCount++;
  } else {
    neighbors.otherTeamCount++;
  }
}

// Find nearby boids using the quadtree structure
void FindNeighborsQuadTree(float2 position, uint boidTeam, uint currentBoidIndex, inout NeighborData neighbors) {
  // Use smaller stack size to reduce register pressure
  uint stack[8]; 
  uint stackSize = 0;
  
  // Start from current boid's assigned node
  uint boidCurrentNodeIdx = 0; // Default to root
  
  // Find the node index for this boid
  for (uint i = 0; i < numBoids; i++) {
    if (boidIndices[i * 2] == currentBoidIndex) {
      boidCurrentNodeIdx = boidIndices[i * 2 + 1];
      break;
    }
  }
  
  // Add the current node and root node to the search stack
  stack[0] = boidCurrentNodeIdx;
  stackSize = 1;
  
  // Also add the root node if not already added
  if (boidCurrentNodeIdx != 0) {
    stack[stackSize++] = 0;
  }
  
  while (stackSize > 0) {
    // Pop a node from the stack
    uint nodeIndex = stack[--stackSize];
    QuadNode node = quadNodes[nodeIndex];
    
    // Skip empty nodes
    if (node.count == 0) continue;
    
    // Distance check to early reject nodes that are too far away
    float2 diff = position - node.center;
    float distSq = dot(diff, diff);
    
    // Use a more generous radius check to ensure we find enough neighbors
    // Node is too far away if distance to center is greater than visual range plus node size
    if (distSq > visualRangeSq + node.size * node.size * 4.0) continue;
    
    if ((node.flags & NODE_LEAF) != 0) {
      // Skip invalid nodes
      if (nodeIndex >= MaxQuadNodes || node.count == 0) continue;
      
      // Scan all boids in this leaf node
      uint scanLimit = min(numBoids, 4096u);
      
      for (uint i = 0; i < scanLimit; i++) {
        uint checkNodeIdx = boidIndices[i * 2 + 1];
        
        // Only process boids in this node
        if (checkNodeIdx == nodeIndex) {
          uint otherBoidIndex = boidIndices[i * 2];
          ProcessNeighborBoid(position, boidTeam, currentBoidIndex, otherBoidIndex, neighbors);
        }
      }
    } 
    else if (node.childIndex > 0) {
      // Add children to stack for non-leaf nodes
      for (uint i = 0; i < 4; i++) {
        uint childIndex = node.childIndex + i;
        // Only add if we have space and child is valid
        if (childIndex < MaxQuadNodes && stackSize < 8) {
          stack[stackSize++] = childIndex;
        }
      }
    }
  }
}

// Find nearby boids using the grid structure
void FindNeighborsGrid(float2 position, uint2 gridXY, uint boidTeam, uint boidIndex, inout NeighborData neighbors) {
  uint cell = getGridID(gridXY);
  
  // Safety check for grid boundaries
  if (cell >= gridDimX * gridDimY || cell < gridDimX * 2) {
    return;
  }
  
  // Examine cells in a 3x3 neighborhood
  for (uint y = cell - gridDimX; y <= cell + gridDimX; y += gridDimX) {
    // Skip cells outside the grid
    if (y < 2 || y >= gridDimX * gridDimY - 1) continue;
    
    uint start = gridOffsetBuffer[y - 2];
    uint end = gridOffsetBuffer[y + 1];
    
    // Skip empty cells
    if (start >= end) continue;
    
    for (uint i = start; i < end; i++) {
      // Safety check for array bounds
      if (i >= numBoids) continue;
      
      // Use the common boid processing function
      ProcessNeighborBoid(position, boidTeam, boidIndex, i, neighbors);
    }
  }
}

// Find all neighbors for a boid using either quadtree or grid
void FindNeighbors(Boid boid, uint boidIndex, inout NeighborData neighbors) {
  if (useQuadTree == 1) {
    FindNeighborsQuadTree(boid.pos, boid.team, boidIndex, neighbors);
  } else {
    uint2 gridXY = getGridLocation(boid);
    FindNeighborsGrid(boid.pos, gridXY, boid.team, boidIndex, neighbors);
  }
}

//-----------------------------------------------------------------------------
// Flocking behavior functions
//-----------------------------------------------------------------------------

// Calculate cohesion force: steer towards center of mass
float2 CalculateCohesion(float2 position, float2 centerOfMass, uint neighborCount) {
  if (neighborCount == 0) return float2(0, 0);
  
  // Calculate average position
  centerOfMass /= neighborCount;
  
  // Calculate direction to center of mass
  float2 cohesionForce = centerOfMass - position;
  float cohesionMag = length(cohesionForce);
  
  // Apply cohesion only if we have a meaningful direction
  if (cohesionMag > 0.0001) {
    // Normalize and apply cohesion with strength proportional to distance
    cohesionForce = normalize(cohesionForce) * min(cohesionMag, 1.0);
    return cohesionForce * (cohesionFactor * intraTeamCohesionMultiplier * deltaTime);
  }
  
  return float2(0, 0);
}

// Calculate alignment force: match velocity with neighbors
float2 CalculateAlignment(float2 currentVel, float2 averageVel, uint neighborCount) {
  if (neighborCount == 0) return float2(0, 0);
  
  // Calculate average velocity
  averageVel /= neighborCount;
  
  // Calculate alignment force
  float2 alignmentForce = averageVel - currentVel;
  return alignmentForce * (alignmentFactor * deltaTime);
}

// Calculate separation force: avoid crowding neighbors
float2 CalculateSeparation(float2 separationForce) {
  float separationMag = length(separationForce);
  
  if (separationMag > 0.0001) {
    // Scale separation by the magnitude of total separation force
    // This ensures stronger avoidance when there are many close neighbors
    float sepStrength = min(separationMag * 2.0, 5.0); // Cap the max strength
    return normalize(separationForce) * sepStrength * (separationFactor * deltaTime);
  }
  
  return float2(0, 0);
}

// Calculate avoidance force from obstacles
float2 CalculateObstacleAvoidance(float2 position) {
  float2 avoidanceForce = float2(0, 0);
  
  for (uint i = 0; i < numObstacles; i++) {
    float2 diff = position - obstacles[i].pos;
    float distance = length(diff);
    
    if (distance < obstacles[i].radius) {
      // Normalize and scale the force inversely with distance
      float2 direction = normalize(diff);
      float force = obstacles[i].strength * (1.0 - (distance / obstacles[i].radius));
      avoidanceForce += direction * force;
    }
  }
  
  return avoidanceForce;
}

// Enforce speed limits on a boid
void LimitSpeed(inout Boid boid) {
  float speed = length(boid.vel);
  
  // Avoid division by zero
  if (speed > 0.0001) {
    float clampedSpeed = clamp(speed, minSpeed, maxSpeed);
    boid.vel *= clampedSpeed / speed;
  } else {
    // If speed is near zero, give it a small random velocity
    boid.vel = float2(0.01, 0.01);
  }
}

// Keep boids within the simulation boundaries
void KeepInBounds(inout Boid boid) {
  if (abs(boid.pos.x) > xBound) {
    boid.vel.x -= sign(boid.pos.x) * deltaTime * turnSpeed;
  }
  if (abs(boid.pos.y) > yBound) {
    boid.vel.y -= sign(boid.pos.y) * deltaTime * turnSpeed;
  }
}

// Apply all flocking behaviors based on neighbor data
void ApplyFlockingBehaviors(inout Boid boid, NeighborData neighbors) {
  // Apply cohesion: steer towards center of mass of same-team neighbors
  float2 cohesionForce = CalculateCohesion(boid.pos, neighbors.centerOfMass, neighbors.sameTeamCount);
  
  // Apply alignment: match velocity with same-team neighbors
  float2 alignmentForce = CalculateAlignment(boid.vel, neighbors.averageVelocity, neighbors.sameTeamCount);
  
  // Apply separation: avoid crowding neighbors
  float2 separationForce = CalculateSeparation(neighbors.separationForce);
  
  // Apply obstacle avoidance
  float2 obstacleForce = CalculateObstacleAvoidance(boid.pos);
  
  // Combine all forces and apply to velocity
  boid.vel += cohesionForce + alignmentForce + separationForce;
  
  // Apply obstacle avoidance separately only if significant
  if (length(obstacleForce) > 0.0001) {
    boid.vel += obstacleForce * obstacleAvoidanceWeight * deltaTime;
  }
}

//-----------------------------------------------------------------------------
// Main update kernel
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// Initialize a clean NeighborData struct
//-----------------------------------------------------------------------------
void InitializeNeighborData(out NeighborData neighbors) {
  neighbors.centerOfMass = float2(0, 0);
  neighbors.separationForce = float2(0, 0);
  neighbors.averageVelocity = float2(0, 0);
  neighbors.sameTeamCount = 0;
  neighbors.otherTeamCount = 0;
}

#pragma kernel UpdateBoids
[numthreads(blockSize, 1, 1)]
void UpdateBoids(uint3 id : SV_DispatchThreadID) {
  // Early exit for threads beyond boid count
  if (id.x >= numBoids) return;
  
  // Get the current boid
  Boid boid = boidsIn[id.x];
  
  // Initialize neighbor data structure
  NeighborData neighbors;
  InitializeNeighborData(neighbors);
  
  // Find all neighbors
  FindNeighbors(boid, id.x, neighbors);
  
  // Apply all flocking behaviors
  ApplyFlockingBehaviors(boid, neighbors);
  
  // Apply physical constraints
  LimitSpeed(boid);
  KeepInBounds(boid);
  
  // Update position based on velocity
  boid.pos += boid.vel * deltaTime;
  
  // Write the updated boid back to the buffer
  boidsOut[id.x] = boid;
}

//-----------------------------------------------------------------------------
// Boid generation kernel
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// Create a new randomized boid with appropriate team and status
//-----------------------------------------------------------------------------
Boid CreateRandomizedBoid(uint index) {
  // Initialize random number generator with unique seed per boid
  rngState = randSeed + index;
  
  Boid boid;
  
  // Generate random position within bounds
  boid.pos = float2(randPCG(-xBound, xBound), randPCG(-yBound, yBound));
  
  // Generate random velocity within speed limits
  boid.vel = float2(randPCG(-maxSpeed, maxSpeed), randPCG(-maxSpeed, maxSpeed));
  
  // Determine team based on teamRatio
  uint threshold = (uint)(numBoids * teamRatio);
  boid.team = index < threshold ? 0u : 1u;
  
  // Assign officer status based on officerRatio
  float officerRoll = randPCG(0.0, 1.0);
  boid.status = officerRoll < officerRatio ? 1u : 0u;
  
  return boid;
}

#pragma kernel GenerateBoids
[numthreads(blockSize, 1, 1)]
void GenerateBoids(uint3 id : SV_DispatchThreadID) {
  // Early exit for threads beyond boid count
  if (id.x >= numBoids) return;
  
  // Create and write randomized boid to output buffer
  boidsOut[id.x] = CreateRandomizedBoid(id.x);
}