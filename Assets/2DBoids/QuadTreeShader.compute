// Optimized Quad-tree implementation for boid simulation
#define blockSize 256  // Reduced from 1024 to 256 for better occupancy
#define NODE_LEAF 1
#define NODE_ACTIVE 2
#define MaxQuadNodes 65536  // Increased from 16384 to 65536 for high boid counts
#define BOUNDARY_THRESHOLD 0.3  // Fraction of quad size to consider "near boundary" (increased from 0.1 to fix detection)
#define VELOCITY_FRAMES_AHEAD 5.0 // How many frames ahead to project velocity (increased from 1.5 to improve detection)
#define HIGH_BOID_COUNT_THRESHOLD 25000 // Threshold to activate high-performance optimizations

struct Boid {
    float2 pos;
    float2 vel;
    uint team;
    uint status; // 0 = regular boid, 1 = officer
};

struct BoidWithHistory {
    float2 pos;      // Current position
    float2 prevPos;  // Previous position for tracking movement
    float2 vel;
    uint team;
    uint status;     // 0 = regular boid, 1 = officer
    uint nodeIndex;  // Current quadtree node index
};

struct QuadNode {
    float2 center;
    float size;
    uint childIndex;    // Index of first child (other children are at +1, +2, +3)
    uint startIndex;    // Start index of boids in this node
    uint count;         // Number of boids in this node
    uint flags;         // Bit flags: 1=leaf, 2=active, etc.
};

// Input/output buffers
RWStructuredBuffer<QuadNode> quadNodes;
RWStructuredBuffer<uint> nodeCount;          // Single element counter
RWStructuredBuffer<uint> activeNodeCount;    // Single element counter
RWStructuredBuffer<uint> activeNodes;        // List of active node indices
RWStructuredBuffer<uint> boidIndices;        // Maps from quadtree order to boid index
StructuredBuffer<Boid> boids;                // Original boids
RWStructuredBuffer<Boid> boidsOut;           // Reordered boids
RWStructuredBuffer<uint> nodeCounts;         // Dedicated buffer for atomic counting
RWStructuredBuffer<BoidWithHistory> boidHistory; // Tracks boid history for incremental updates
RWStructuredBuffer<uint> movedBoidIndices;   // Indices of boids that moved significantly
RWStructuredBuffer<uint> movedBoidCount;     // Number of boids that moved significantly

// Parameters
uint maxDepth;             // Maximum depth of the quad-tree
uint maxBoidsPerNode;      // Maximum boids per leaf node before subdivision
uint numBoids;             // Total number of boids
float worldSize;           // Size of the world (half-width)
float deltaTime;           // Time since last frame

// Determine which quadrant a point belongs to (0=NE, 1=NW, 2=SW, 3=SE)
uint GetQuadrant(float2 center, float2 pos) {
    uint quadrant = 0;
    if (pos.x < center.x) quadrant |= 1;
    if (pos.y < center.y) quadrant |= 2;
    return quadrant;
}

// Get child center based on parent center and quadrant
float2 GetChildCenter(float2 parentCenter, float parentSize, uint quadrant) {
    // Calculate child size (half of parent size)
    float childSize = parentSize * 0.5;
    
    // For proper quadtree tiling:
    // - Each child needs to be placed at a full childSize offset from the parent center
    // - This ensures the child's edge aligns with the parent center, properly tiling the space
    float offsetX = (quadrant & 1) ? -childSize : childSize;
    float offsetY = (quadrant & 2) ? -childSize : childSize;
    
    return parentCenter + float2(offsetX, offsetY);
}

#pragma kernel InitializeQuadTree
[numthreads(blockSize, 1, 1)]
void InitializeQuadTree(uint3 id : SV_DispatchThreadID) {
    // Thread 0 initializes the core structures
    if (id.x == 0) {
        // Always reset to a clean state with just one root node
        nodeCount[0] = 1;
        activeNodeCount[0] = 1;
        
        // Initialize root node as a leaf
        QuadNode root;
        root.center = float2(0, 0);
        root.size = worldSize;
        root.childIndex = 0;  // No children initially
        root.startIndex = 0;
        root.count = 0;
        root.flags = NODE_LEAF | NODE_ACTIVE;  // Must be a leaf to start
        
        quadNodes[0] = root;
        activeNodes[0] = 0;
    }
    
    // All threads clear node counts in parallel
    if (id.x < MaxQuadNodes) {
        // Clear all node counts
        nodeCounts[id.x] = 0;
        
        // For nodes other than root, reset completely
        if (id.x > 0) {
            QuadNode node;
            node.center = float2(0, 0);
            node.size = 0;
            node.childIndex = 0;
            node.startIndex = 0;
            node.count = 0;
            node.flags = 0;  // Inactive and not a leaf
            
            quadNodes[id.x] = node;
        }
    }
}

// OPTIMIZATION: This legacy kernel is kept for compatibility but can be removed
#pragma kernel ClearQuadTree
[numthreads(1, 1, 1)]
void ClearQuadTree() {
    // Reset counters
    nodeCount[0] = 1;
    activeNodeCount[0] = 1;
    
    // Initialize root node
    QuadNode root;
    root.center = float2(0, 0);
    root.size = worldSize;
    root.childIndex = 0;
    root.startIndex = 0;
    root.count = 0;
    root.flags = NODE_LEAF | NODE_ACTIVE;
    
    quadNodes[0] = root;
    activeNodes[0] = 0;
}

// OPTIMIZATION: Legacy support for backward compatibility
#pragma kernel ActivateRoot
[numthreads(1, 1, 1)]
void ActivateRoot() {
    // Only needed if not using InitializeQuadTree
    QuadNode root = quadNodes[0];
    root.flags |= NODE_ACTIVE;
    quadNodes[0] = root;
    activeNodeCount[0] = 1;
    activeNodes[0] = 0;
}

// Initialize boid history buffer - used when we first create the quadtree
#pragma kernel InitializeBoidHistory
[numthreads(blockSize, 1, 1)]
void InitializeBoidHistory(uint3 id : SV_DispatchThreadID) {
    if (id.x >= numBoids) return;
    
    // Get current boid
    Boid boid = boids[id.x];
    
    // Create history entry with current position as both current and previous
    BoidWithHistory boidHist;
    boidHist.pos = boid.pos;
    boidHist.prevPos = boid.pos; // Initialize previous pos to current
    boidHist.vel = boid.vel;
    boidHist.team = boid.team;
    boidHist.nodeIndex = 0; // Default to root node
    
    // Write to history buffer
    boidHistory[id.x] = boidHist;
    
    // Reset moved boid count on first thread
    if (id.x == 0) {
        movedBoidCount[0] = 0;
    }
}

// Insert boids into the quadtree (kernel 1)
#pragma kernel InsertBoids
[numthreads(blockSize, 1, 1)]
void InsertBoids(uint3 id : SV_DispatchThreadID) {
    if (id.x >= numBoids) return;
    
    // Assign all boids to the root node initially
    boidIndices[id.x * 2] = id.x;     // Original boid index
    boidIndices[id.x * 2 + 1] = 0;     // Assigned to root node
    
    // Count boids in root node using atomic increment
    InterlockedAdd(nodeCounts[0], 1);
}


// OPTIMIZATION: Update node counts from the atomic counters
#pragma kernel UpdateNodeCounts
[numthreads(blockSize, 1, 1)]
void UpdateNodeCounts(uint3 id : SV_DispatchThreadID) {
    uint totalNodes;
    InterlockedAdd(nodeCount[0], 0, totalNodes);
    
    if (id.x >= totalNodes) return;
    
    // Copy count from nodeCounts to the node structure
    QuadNode node = quadNodes[id.x];
    node.count = nodeCounts[id.x];
    quadNodes[id.x] = node;
}

// OPTIMIZATION: Clear node counts efficiently
#pragma kernel ClearNodeCounts
[numthreads(blockSize, 1, 1)]
void ClearNodeCounts(uint3 id : SV_DispatchThreadID) {
    if (id.x >= MaxQuadNodes) return;
    
    // Reset all node counts
    nodeCounts[id.x] = 0;
}

// OPTIMIZATION: Sort boids using quadtree structure with better memory access
#pragma kernel SortBoids
[numthreads(blockSize, 1, 1)]
void SortBoids(uint3 id : SV_DispatchThreadID) {
    if (id.x >= numBoids) return;
    
    // Get the boid index from quadtree order
    uint boidIdx = boidIndices[id.x * 2];
    uint nodeIdx = boidIndices[id.x * 2 + 1]; // Get the node this boid is assigned to
    
    // Safety check
    if (boidIdx >= numBoids) return;
    
    // Read once, write once for better memory performance
    Boid boid = boids[boidIdx];
    boidsOut[id.x] = boid;
    
    // IMPORTANT: Also update the boid history with the current node assignment
    // This is critical for incremental updates to work correctly
    BoidWithHistory boidHist = boidHistory[boidIdx];
    
    // Always ensure node assignment is correctly synchronized
    if (boidHist.nodeIndex != nodeIdx) {
        boidHist.nodeIndex = nodeIdx;
        boidHistory[boidIdx] = boidHist;
    }
}


#pragma kernel DiagnoseSubdivision
RWStructuredBuffer<uint> diagData;

[numthreads(1, 1, 1)]
void DiagnoseSubdivision() {
    // Get the root node for analysis
    QuadNode rootNode = quadNodes[0];
    
    // 1. Check leaf flag
    bool isLeaf = (rootNode.flags & NODE_LEAF) != 0;
    diagData[0] = isLeaf ? 1 : 0;
    
    // 2. Check count vs threshold
    bool countExceedsThreshold = rootNode.count > maxBoidsPerNode;
    diagData[1] = countExceedsThreshold ? 1 : 0;
    
    // 3. Check node count limit
    bool hasSpaceForChildren = nodeCount[0] < (MaxQuadNodes - 4);
    diagData[2] = hasSpaceForChildren ? 1 : 0;
    
    // 4. Check size threshold
    bool sizeAboveThreshold = rootNode.size > 2.0;
    diagData[3] = sizeAboveThreshold ? 1 : 0;
    
    // Store actual values for reference
    diagData[4] = rootNode.flags;
    diagData[5] = rootNode.count;
    diagData[6] = maxBoidsPerNode;
    diagData[7] = nodeCount[0];
    diagData[8] = (uint)rootNode.size;
    
    // Store a distinct marker to verify this kernel ran
    diagData[9] = 0xDEADBEEF;
}

#pragma kernel ForceRedistributeRootBoids
[numthreads(256, 1, 1)]
void ForceRedistributeRootBoids(uint3 id : SV_DispatchThreadID) {
    if (id.x >= numBoids) return;
    
    // Get boid info
    uint boidIndex = boidIndices[id.x * 2];
    uint nodeIndex = boidIndices[id.x * 2 + 1];
    
    // Only process boids in the root node
    if (nodeIndex != 0) return;
    
    // Get the boid position
    Boid boid = boids[boidIndex];
    
    // Get the root node
    QuadNode rootNode = quadNodes[0];
    
    // Only proceed if root has children and is not a leaf
    if ((rootNode.flags & NODE_LEAF) != 0 || rootNode.childIndex <= 0 || rootNode.childIndex >= MaxQuadNodes) 
        return;
    
    // CRITICAL FIX: Traverse the tree to find a leaf node for this boid
    uint currentNodeIndex = 0; // Start at root
    QuadNode currentNode = rootNode;
    
    // Keep traversing down until we reach a leaf node
    while ((currentNode.flags & NODE_LEAF) == 0 && currentNode.childIndex > 0) {
        // Determine quadrant
        uint quadrant = 0;
        if (boid.pos.x < currentNode.center.x) quadrant |= 1; // west
        if (boid.pos.y < currentNode.center.y) quadrant |= 2; // south
        
        // Calculate child node index
        uint childIndex = currentNode.childIndex + quadrant;
        
        // Safety checks
        if (childIndex >= MaxQuadNodes || childIndex == currentNodeIndex) 
            break;
        
        // Move to child node
        currentNodeIndex = childIndex;
        currentNode = quadNodes[currentNodeIndex];
    }
    
    // Make sure we didn't end up at the root node
    if (currentNodeIndex == 0) return;
    
    // Force-update both the boid indices and history for consistency
    boidIndices[id.x * 2 + 1] = currentNodeIndex;
    
    // Update history record too
    BoidWithHistory boidHist = boidHistory[boidIndex];
    boidHist.nodeIndex = currentNodeIndex;
    boidHistory[boidIndex] = boidHist;
    
    // Update node counts
    InterlockedAdd(nodeCounts[0], -1); // Decrement root count
    InterlockedAdd(nodeCounts[currentNodeIndex], 1); // Increment target node count
}

// OPTIMIZATION: Combined operation for subdividing and redistributing
#pragma kernel SubdivideAndRedistribute
[numthreads(blockSize, 1, 1)]
void SubdivideAndRedistribute(uint3 id : SV_DispatchThreadID) {
    // PHASE 1: Subdivision phase - separate from redistribution
    uint totalActiveNodes;
    InterlockedAdd(activeNodeCount[0], 0, totalActiveNodes);
    
    // All threads participate in sync barriers regardless of flow path
    bool canSubdivide = false;
    uint nodeIndex = 0;
    // Initialize node with default values to avoid the warning
    QuadNode node = (QuadNode)0; // Initialize all fields to zero
    
    if (id.x < totalActiveNodes) {
        nodeIndex = activeNodes[id.x];
        node = quadNodes[nodeIndex];
        
        // Check subdivision conditions without early exit
        bool isLeaf = (node.flags & NODE_LEAF) != 0;
        bool exceededThreshold = node.count > maxBoidsPerNode;
        bool hasSpace = nodeCount[0] < MaxQuadNodes - 4;
        bool sizeOK = node.size > 2.0;
        
        canSubdivide = isLeaf && exceededThreshold && hasSpace && sizeOK;
    }
    
    // All threads must reach this barrier
    DeviceMemoryBarrier();
    
    // Only threads that need to subdivide continue with subdivision
    uint childIndex = 0;
    if (canSubdivide) {
        // Allocate children
        InterlockedAdd(nodeCount[0], 4, childIndex);
        
        if (childIndex + 4 < MaxQuadNodes) {
            // Update parent
            node.childIndex = childIndex;
            node.flags &= ~NODE_LEAF;
            quadNodes[nodeIndex] = node;
            
            // Create children
            float childSize = node.size * 0.5;
            for (uint i = 0; i < 4; i++) {
                uint qx = i & 1; // 0 for east, 1 for west
                uint qy = (i & 2) >> 1; // 0 for north, 1 for south
                
                // Position the child at the correct quadrant
                // For proper tiling without gaps or overlaps, we need a full childSize offset
                float offsetX = (qx == 0) ? childSize : -childSize;
                float offsetY = (qy == 0) ? childSize : -childSize;
                
                QuadNode child;
                child.center = node.center + float2(offsetX, offsetY);
                child.size = childSize;
                child.childIndex = 0;
                child.startIndex = 0;
                child.count = 0;
                child.flags = NODE_LEAF | NODE_ACTIVE;
                
                quadNodes[childIndex + i] = child;
                
                uint activeIdx;
                InterlockedAdd(activeNodeCount[0], 1, activeIdx);
                
                if (activeIdx < MaxQuadNodes) {
                    activeNodes[activeIdx] = childIndex + i;
                }
            }
        }
    }
    
    // All threads must reach this barrier before redistribution begins
    DeviceMemoryBarrier();
    
    // PHASE A: First, clear out node counts for accurate recounting
    if (id.x < MaxQuadNodes) {
        nodeCounts[id.x] = 0;
    }
    
    // Ensure all threads complete the clearing
    DeviceMemoryBarrier();
    
    // PHASE B: Assign each boid to its appropriate node
    if (id.x < numBoids) {
        uint boidIndex = boidIndices[id.x * 2];
        Boid boid = boids[boidIndex];
        
        // Start from root node (index 0) for consistent traversal
        uint currentNodeIndex = 0;
        QuadNode currentNode = quadNodes[currentNodeIndex];
        
        // Traverse the tree to find the correct leaf node for this boid
        while ((currentNode.flags & NODE_LEAF) == 0 && currentNode.childIndex > 0) {
            // Determine quadrant
            uint quadrant = 0;
            quadrant |= (boid.pos.x < currentNode.center.x) ? 1 : 0;
            quadrant |= (boid.pos.y < currentNode.center.y) ? 2 : 0;
            
            // Move to child node
            uint newNodeIndex = currentNode.childIndex + quadrant;
            
            // Safety check to avoid infinite loops
            if (newNodeIndex >= MaxQuadNodes || newNodeIndex == currentNodeIndex) {
                break;
            }
            
            currentNodeIndex = newNodeIndex;
            currentNode = quadNodes[currentNodeIndex];
        }
        
        // Update boid assignment
        boidIndices[id.x * 2 + 1] = currentNodeIndex;
        
        // Increment the node count for this node
        InterlockedAdd(nodeCounts[currentNodeIndex], 1);
    }
    
    // Ensure all boids are assigned before updating node counts
    DeviceMemoryBarrier();
    
    // PHASE C: Update node counts from the nodeCounts buffer
    if (id.x < MaxQuadNodes) {
        QuadNode updatedNode = quadNodes[id.x];
        updatedNode.count = nodeCounts[id.x];
        quadNodes[id.x] = updatedNode;
    }
}

#pragma kernel ResetRootNode
[numthreads(1, 1, 1)]
void ResetRootNode() {
    // Reset just the root node to ensure it starts as a leaf
    QuadNode root;
    root.center = float2(0, 0);
    root.size = worldSize;
    root.childIndex = 0;  // No children
    root.startIndex = 0;
    root.count = 0;
    root.flags = NODE_LEAF | NODE_ACTIVE;  // Force LEAF flag
    
    quadNodes[0] = root;
    nodeCount[0] = 1;  // Reset to just one node
    activeNodeCount[0] = 1;
    activeNodes[0] = 0;
}

// Collapse empty or near-empty nodes back into their parent
#pragma kernel CollapseNodes
[numthreads(blockSize, 1, 1)]
void CollapseNodes(uint3 id : SV_DispatchThreadID) {
    // Get total active nodes to process
    uint totalActiveNodes;
    InterlockedAdd(activeNodeCount[0], 0, totalActiveNodes);
    
    // Only process active nodes
    if (id.x >= totalActiveNodes) return;
    
    // Get the active node index
    uint nodeIndex = activeNodes[id.x];
    QuadNode node = quadNodes[nodeIndex];
    
    // Skip if this is not a non-leaf node that wants to collapse
    if ((node.flags & NODE_LEAF) != 0 || node.count >= (maxBoidsPerNode / 4)) return;
    
    // Check if all children are leaves with few boids in total
    bool canCollapse = true;
    uint totalChildBoids = 0;
    uint totalNodes;
    InterlockedAdd(nodeCount[0], 0, totalNodes);
    
    // Skip if no valid children
    if (node.childIndex <= 0 || node.childIndex >= totalNodes) return;
    
    // Check each child
    for (uint i = 0; i < 4; i++) {
        uint childIdx = node.childIndex + i;
        if (childIdx >= totalNodes) continue;
        
        QuadNode child = quadNodes[childIdx];
        totalChildBoids += child.count;
        
        // If any child is not a leaf, we can't collapse
        if ((child.flags & NODE_LEAF) == 0) {
            canCollapse = false;
            break;
        }
    }
    
    // Only collapse if all children together have few enough boids
    if (canCollapse && totalChildBoids < maxBoidsPerNode) {
        // Turn this node back into a leaf
        node.flags |= NODE_LEAF;
        
        // IMPROVED APPROACH THAT WORKS FOR ALL BOID COUNTS
        // This method handles node collapsing more efficiently
        
        // If this is a low boid count, we can do a complete redistribution
        if (numBoids < HIGH_BOID_COUNT_THRESHOLD) {
            // Process each boid to check if it's in one of the children
            for (uint j = 0; j < numBoids; j++) {
                uint boidIdx = boidIndices[j * 2];
                uint boidNodeIndex = boidIndices[j * 2 + 1];
                
                // Check if this boid is in one of the children
                bool inChild = false;
                for (uint k = 0; k < 4; k++) {
                    uint childIdx = node.childIndex + k;
                    if (boidNodeIndex == childIdx) {
                        inChild = true;
                        break;
                    }
                }
                
                if (inChild) {
                    // Move boid to this node in the indices array
                    boidIndices[j * 2 + 1] = nodeIndex;
                    
                    // Also update the history record for proper incremental updates
                    BoidWithHistory boidHist = boidHistory[boidIdx];
                    boidHist.nodeIndex = nodeIndex;
                    boidHistory[boidIdx] = boidHist;
                }
            }
        } else {
            // For high boid counts, use a more efficient approach
            // We'll scan the boid indices and update only those that match our child nodes
            
            // Create a small local buffer to store children indices for fast lookup
            uint childIndices[4];
            for (uint c = 0; c < 4; c++) {
                childIndices[c] = node.childIndex + c;
            }
            
            // Process a subset of boids per thread
            uint boidsPerThread = (numBoids + blockSize - 1) / blockSize;
            uint startIdx = id.x * boidsPerThread;
            uint endIdx = min(startIdx + boidsPerThread, numBoids);
            
            // Process only the boid range assigned to this thread
            for (uint j = startIdx; j < endIdx; j++) {
                uint boidIdx = boidIndices[j * 2];
                uint boidNodeIndex = boidIndices[j * 2 + 1];
                
                // Check if this boid is in one of our children
                for (uint k = 0; k < 4; k++) {
                    if (boidNodeIndex == childIndices[k]) {
                        // Update the assignment to this node
                        boidIndices[j * 2 + 1] = nodeIndex;
                        
                        // Update history
                        BoidWithHistory boidHist = boidHistory[boidIdx];
                        boidHist.nodeIndex = nodeIndex;
                        boidHistory[boidIdx] = boidHist;
                        break;
                    }
                }
            }
        }
        
        // Also flag the children nodes to ensure any boids we missed will be reclassified
        for (uint k = 0; k < 4; k++) {
            uint childIdx = node.childIndex + k;
            if (childIdx < totalNodes) {
                QuadNode childNode = quadNodes[childIdx];
                childNode.flags |= 0x10; // Mark as needing reclassification
                quadNodes[childIdx] = childNode;
            }
        }
        
        // Update the node count
        node.count = totalChildBoids;
        nodeCounts[nodeIndex] = totalChildBoids;
        
        // Set child nodes as inactive
        for (uint m = 0; m < 4; m++) {
            uint childIdx = node.childIndex + m;
            if (childIdx < totalNodes) {
                QuadNode child = quadNodes[childIdx];
                child.count = 0;
                child.flags &= ~NODE_ACTIVE;  // Clear active flag
                quadNodes[childIdx] = child;
                nodeCounts[childIdx] = 0;
            }
        }
        
        // Mark children as available for reuse by clearing childIndex
        // but keep the reference for later cleanup if needed
        // node.childIndex = 0;
        
        // Write back the updated node
        quadNodes[nodeIndex] = node;
    }
}

#pragma kernel RecountBoids
[numthreads(blockSize, 1, 1)]
void RecountBoids(uint3 id : SV_DispatchThreadID) {
    if (id.x >= numBoids) return;
    
    // Get the node this boid is assigned to
    uint nodeIndex = boidIndices[id.x * 2 + 1];
    
    // Increment the count for this node
    if (nodeIndex < MaxQuadNodes) {
        InterlockedAdd(nodeCounts[nodeIndex], 1);
    }
}



#pragma kernel DebugSubdivision
RWStructuredBuffer<uint> subdivDebug;  // Add this buffer

[numthreads(1, 1, 1)]
void DebugSubdivision() {
    // Check root node
    QuadNode root = quadNodes[0];
    
    // Output debug info
    subdivDebug[0] = root.flags;  // Should have NODE_LEAF bit set
    subdivDebug[1] = root.count;  // Should be > maxBoidsPerNode
    subdivDebug[2] = nodeCount[0]; // Current node count
    subdivDebug[3] = MaxQuadNodes - 4; // Max nodes threshold
    subdivDebug[4] = (uint)(root.size); // Root size
    subdivDebug[5] = maxBoidsPerNode; // Threshold
    subdivDebug[6] = activeNodeCount[0]; // Should be 1 initially
    
    // Individual condition checks (1 = pass, 0 = fail)
    subdivDebug[7] = (root.flags & NODE_LEAF) != 0 ? 1 : 0; // is leaf?
    subdivDebug[8] = root.count > maxBoidsPerNode ? 1 : 0; // exceeds threshold?
    subdivDebug[9] = nodeCount[0] < MaxQuadNodes - 4 ? 1 : 0; // room for children?
}

#pragma kernel TestMaxBoidsPerNode
RWStructuredBuffer<uint> testBuffer;

[numthreads(1, 1, 1)]
void TestMaxBoidsPerNode() {
    // Simply copy the value directly
    testBuffer[0] = maxBoidsPerNode;
}

// Track which boids are likely to cross a quadtree boundary
#pragma kernel TrackMovedBoids
[numthreads(blockSize, 1, 1)]
void TrackMovedBoids(uint3 id : SV_DispatchThreadID) {
    if (id.x >= numBoids) return;
    
    // Reset the moved boid count for first thread
    if (id.x == 0) {
        movedBoidCount[0] = 0;
    }
    
    // Ensure the count is initialized before proceeding
    DeviceMemoryBarrier();
    
    // Get current boid data
    Boid currentBoid = boids[id.x];
    BoidWithHistory boidHist = boidHistory[id.x];
    
    // SIMPLIFIED DECISION TREE FOR LARGE BOID COUNTS
    // To address the 0% update issue, we'll use a more aggressive approach
    
    // Get the current node this boid belongs to
    uint nodeIndex = boidHist.nodeIndex;
    bool needsUpdate = false;
    
    // Always force update if:
    // 1. The node index is invalid
    // 2. The node has been flagged for reclassification
    if (nodeIndex >= MaxQuadNodes) {
        needsUpdate = true;
    }
    else {
        QuadNode node = quadNodes[nodeIndex];
        
        // Check for reclassification flag first (very efficient check)
        if ((node.flags & 0x10) != 0) {
            needsUpdate = true;
        }
        else {
            float2 boidPos = currentBoid.pos;
            float nodeSize = node.size;
            float2 nodeCenter = node.center;
            
            // For 60K+ boids, use different update strategies
            if (numBoids > 50000) {
                // HIGH BOID COUNT SPECIAL CASE - Use multiple update strategies
                
                // Strategy 1: Position-based checks (outside quad or moving toward boundary)
                bool outsideQuad = 
                    boidPos.x < (nodeCenter.x - nodeSize) || 
                    boidPos.x > (nodeCenter.x + nodeSize) ||
                    boidPos.y < (nodeCenter.y - nodeSize) || 
                    boidPos.y > (nodeCenter.y + nodeSize);
                
                if (outsideQuad) {
                    needsUpdate = true;
                }
                else {
                    // Strategy 2: Use random sampling to ensure sufficient updates
                    // For really large populations, randomly update a percentage of boids
                    // This ensures we don't miss important reconfigurations
                    uint hash = id.x * 747796405 + id.y * 2891336453 + id.z;
                    hash = ((hash >> 13) ^ hash) * 1597334677;
                    hash = ((hash >> 9) ^ hash) * 1597334677;
                    hash = (hash >> 16) ^ hash;
                    
                    // Randomly update 10% of boids
                    bool randomUpdate = (hash % 10) == 0;
                    
                    // Strategy 3: Movement-based deterministic updates
                    float2 velocity = currentBoid.vel;
                    float2 deltaPos = boidPos - boidHist.prevPos;
                    float moveDistanceSq = dot(deltaPos, deltaPos);
                    
                    // Update if moved significantly or moving fast (0.5 is arbitrary)
                    bool significantMovement = moveDistanceSq > (nodeSize * 0.01);
                    bool fastMoving = length(velocity) > 0.75;
                    
                    needsUpdate = randomUpdate || significantMovement || fastMoving;
                }
            }
            else {
                // NORMAL BOID COUNT CASE - Use standard boundary proximity checks
                
                // First check if boid is outside its quad (most common case)
                bool outsideQuad = 
                    boidPos.x < (nodeCenter.x - nodeSize) || 
                    boidPos.x > (nodeCenter.x + nodeSize) ||
                    boidPos.y < (nodeCenter.y - nodeSize) || 
                    boidPos.y > (nodeCenter.y + nodeSize);
                
                if (outsideQuad) {
                    needsUpdate = true;
                }
                else {
                    // Calculate distance from boid to each boundary
                    float distToLeftBoundary = boidPos.x - (nodeCenter.x - nodeSize);
                    float distToRightBoundary = (nodeCenter.x + nodeSize) - boidPos.x;
                    float distToBottomBoundary = boidPos.y - (nodeCenter.y - nodeSize);
                    float distToTopBoundary = (nodeCenter.y + nodeSize) - boidPos.y;
                    
                    // Calculate threshold distance for boundary proximity
                    float boundaryThreshold = nodeSize * BOUNDARY_THRESHOLD;
                    
                    // Get velocity and calculate projected position
                    float2 velocity = currentBoid.vel;
                    float2 projectedPos = boidPos + (velocity * deltaTime * VELOCITY_FRAMES_AHEAD);
                    
                    // Check boundary proximity with velocity direction
                    bool nearLeftAndMovingLeft = distToLeftBoundary < boundaryThreshold && velocity.x < 0;
                    bool nearRightAndMovingRight = distToRightBoundary < boundaryThreshold && velocity.x > 0;
                    bool nearBottomAndMovingDown = distToBottomBoundary < boundaryThreshold && velocity.y < 0;
                    bool nearTopAndMovingUp = distToTopBoundary < boundaryThreshold && velocity.y > 0;
                    
                    // Check if projected position will be outside the quad
                    bool projectedOutsideQuad = 
                        projectedPos.x < (nodeCenter.x - nodeSize) || 
                        projectedPos.x > (nodeCenter.x + nodeSize) ||
                        projectedPos.y < (nodeCenter.y - nodeSize) || 
                        projectedPos.y > (nodeCenter.y + nodeSize);
                    
                    // Flag boid as needing update based on boundary checks
                    needsUpdate = nearLeftAndMovingLeft || nearRightAndMovingRight || 
                                nearBottomAndMovingDown || nearTopAndMovingUp ||
                                projectedOutsideQuad;
                }
            }
        }
    }
    
    // Add to moved boids list if it needs update
    if (needsUpdate) {
        uint index;
        InterlockedAdd(movedBoidCount[0], 1, index);
        
        // Record this boid's index in the moved list
        if (index < numBoids) {
            movedBoidIndices[index] = id.x;
        }
    }
    
    // Always update the history
    boidHist.prevPos = boidHist.pos;
    boidHist.pos = currentBoid.pos;
    boidHist.vel = currentBoid.vel;
    boidHist.team = currentBoid.team;
    // Keep the current node assignment
    
    // Write back to history buffer
    boidHistory[id.x] = boidHist;
}

// OPTIMIZATION: This is a test/debug kernel that manually subdivides just the root
#pragma kernel TestSubdivide
[numthreads(1, 1, 1)]
void TestSubdivide() {
    // Manually subdivide the root - useful for testing
    QuadNode root = quadNodes[0];
    root.childIndex = 1;
    root.flags &= ~NODE_LEAF;
    
    for (uint i = 0; i < 4; i++) {
        QuadNode child;
        child.center = GetChildCenter(root.center, root.size, i);
        child.size = root.size * 0.5;
        child.childIndex = 0;
        child.startIndex = 0;
        child.count = 0;
        child.flags = NODE_LEAF | NODE_ACTIVE;
        
        quadNodes[1 + i] = child;
    }
    
    quadNodes[0] = root;
    nodeCount[0] = 5;
}

// OPTIMIZATION: This kernel doesn't need to be changed - keeping it for backward compatibility
#pragma kernel CountBoids
[numthreads(blockSize, 1, 1)]
void CountBoids(uint3 id : SV_DispatchThreadID) {
    if (id.x >= numBoids) return;
    
    // Always assign to root for now
    uint nodeIndex = 0;
    
    // Store boid index and node
    boidIndices[id.x * 2] = id.x;
    boidIndices[id.x * 2 + 1] = nodeIndex;
}

// OPTIMIZATION: This kernel doesn't need to be changed - keeping it for backward compatibility
#pragma kernel SumNodeCounts
[numthreads(1, 1, 1)]
void SumNodeCounts() {
    // Reset count
    QuadNode root = quadNodes[0];
    root.count = 0;
    
    // Count all boids assigned to root
    for (uint i = 0; i < numBoids; i++) {
        uint nodeIndex = boidIndices[i * 2 + 1];
        if (nodeIndex == 0) {
            root.count++;
        }
    }
    
    // Write back
    quadNodes[0] = root;
}

// Incremental update of quadtree - only process boids that moved significantly
#pragma kernel IncrementalQuadTreeUpdate
[numthreads(blockSize, 1, 1)]
void IncrementalQuadTreeUpdate(uint3 id : SV_DispatchThreadID) {
    // Get the number of boids that moved significantly
    uint numMovedBoids = movedBoidCount[0];
    
    // Only process if this thread maps to a moved boid
    if (id.x >= numMovedBoids) return;
    
    // Get the actual boid index from the moved list
    uint boidIndex = movedBoidIndices[id.x];
    
    // Get the boid's current data
    Boid boid = boids[boidIndex];
    BoidWithHistory boidHist = boidHistory[boidIndex];
    
    // Get the current node assignment
    uint oldNodeIndex = boidHist.nodeIndex;
    
    // ALWAYS traverse from the root to find the most appropriate node
    // This is important to avoid boids getting stuck in outdated node assignments
    uint newNodeIndex = 0; // Start at root
    QuadNode currentNode = quadNodes[newNodeIndex];
    
    // Traverse the tree to find the correct leaf node for this boid
    // This guarantees proper node assignment even if the tree structure has changed
    while ((currentNode.flags & NODE_LEAF) == 0 && currentNode.childIndex > 0) {
        // Determine which quadrant the boid belongs to
        uint quadrant = 0;
        if (boid.pos.x < currentNode.center.x) quadrant |= 1; // west
        if (boid.pos.y < currentNode.center.y) quadrant |= 2; // south
        
        // Calculate index of the child node for this quadrant
        uint childIndex = currentNode.childIndex + quadrant;
        
        // Safety check
        if (childIndex >= MaxQuadNodes || childIndex == newNodeIndex) {
            break;
        }
        
        // Move to the child node
        newNodeIndex = childIndex;
        currentNode = quadNodes[newNodeIndex];
        
        // Extra check to verify the node is valid and active
        if ((currentNode.flags & NODE_ACTIVE) == 0) {
            // If we reached an inactive node, stop traversal and use parent
            newNodeIndex = oldNodeIndex; // Revert to original node
            break;
        }
    }
    
    // Only update if the boid has moved to a new node
    if (oldNodeIndex != newNodeIndex) {
        // Remove from old node (atomic to avoid race conditions)
        if (oldNodeIndex < MaxQuadNodes) {
            InterlockedAdd(nodeCounts[oldNodeIndex], -1);
        }
        
        // Add to new node (atomic to avoid race conditions)
        InterlockedAdd(nodeCounts[newNodeIndex], 1);
        
        // Update boid's node index
        boidIndices[boidIndex * 2 + 1] = newNodeIndex;
        boidHist.nodeIndex = newNodeIndex;
        boidHistory[boidIndex] = boidHist;
    }
}

// Check if nodes need to be subdivided or merged based on the updated counts
#pragma kernel RepairTreeStructure
[numthreads(blockSize, 1, 1)]
void RepairTreeStructure(uint3 id : SV_DispatchThreadID) {
    // Get total node count
    uint totalNodes;
    InterlockedAdd(nodeCount[0], 0, totalNodes);
    
    if (id.x >= totalNodes) return;
    
    // Copy node counts to the actual node structures
    QuadNode node = quadNodes[id.x];
    node.count = nodeCounts[id.x];
    
    // If this is a leaf node and exceeds threshold, mark as active for subdivision
    if ((node.flags & NODE_LEAF) != 0 && node.count > maxBoidsPerNode) {
        // Mark as active
        node.flags |= NODE_ACTIVE;
        
        // Add to active nodes list
        uint activeIdx;
        InterlockedAdd(activeNodeCount[0], 1, activeIdx);
        
        if (activeIdx < MaxQuadNodes) {
            activeNodes[activeIdx] = id.x;
        }
    }
    // If this is a parent node with very few boids (potentially after boids moved away),
    // consider collapsing it back to a leaf - by marking it active
    else if ((node.flags & NODE_LEAF) == 0 && node.count < (maxBoidsPerNode / 4) && 
             node.childIndex > 0 && node.childIndex < totalNodes) {
        // Check if all children are leaves and have few boids
        bool canCollapse = true;
        uint totalChildBoids = 0;
        
        for (uint i = 0; i < 4; i++) {
            uint childIdx = node.childIndex + i;
            if (childIdx >= totalNodes) continue;
            
            QuadNode child = quadNodes[childIdx];
            totalChildBoids += child.count;
            
            // If any child is not a leaf, we can't collapse
            if ((child.flags & NODE_LEAF) == 0) {
                canCollapse = false;
                break;
            }
        }
        
        // Only collapse if all children together have few boids
        if (canCollapse && totalChildBoids < maxBoidsPerNode) {
            // Mark as active for potential collapse
            node.flags |= NODE_ACTIVE;
            
            // Add to active nodes list for processing
            uint activeIdx;
            InterlockedAdd(activeNodeCount[0], 1, activeIdx);
            
            if (activeIdx < MaxQuadNodes) {
                activeNodes[activeIdx] = id.x;
            }
        }
    }
    
    // Write back node with potentially updated flags
    quadNodes[id.x] = node;
}

#pragma kernel BuildQuadtreeUnified
[numthreads(blockSize, 1, 1)]
void BuildQuadtreeUnified(uint3 id : SV_DispatchThreadID) {
    // PHASE 1: Initialize - Thread 0 handles single-instance initialization
    if (id.x == 0) {
        // Reset node count and active nodes
        nodeCount[0] = 1;
        activeNodeCount[0] = 1;
        
        // Initialize root as a leaf node
        QuadNode root;
        root.center = float2(0, 0);
        root.size = worldSize;
        root.childIndex = 0;
        root.startIndex = 0;
        root.count = 0;
        root.flags = NODE_LEAF | NODE_ACTIVE;
        
        quadNodes[0] = root;
        activeNodes[0] = 0;
    }
    
    // PHASE 2: Clear node counts - All threads participate
    if (id.x < MaxQuadNodes) {
        nodeCounts[id.x] = 0;
    }
    
    // Ensure initialization is complete
    DeviceMemoryBarrier();
    
    // PHASE 3: Insert boids AND update boid history node assignment
    if (id.x < numBoids) {
        // Store the original boid index
        boidIndices[id.x * 2] = id.x;
        
        // Assign to root initially
        boidIndices[id.x * 2 + 1] = 0;
        
        // Also update the boid history record with the correct node assignment
        // This is crucial for incremental updates to work properly
        BoidWithHistory boidHist = boidHistory[id.x];
        boidHist.nodeIndex = 0; // Assign to root node
        boidHistory[id.x] = boidHist;
        
        // Increment root node count
        InterlockedAdd(nodeCounts[0], 1);
    }
    
    // Ensure all boids are inserted and history is updated
    DeviceMemoryBarrier();
    
    // PHASE 4: Update node counts - All threads within MaxQuadNodes participate
    if (id.x < MaxQuadNodes) {
        QuadNode node = quadNodes[id.x];
        node.count = nodeCounts[id.x];
        quadNodes[id.x] = node;
    }
    
    // Ensure node counts are updated
    DeviceMemoryBarrier();
    
    // PHASE 5: Multi-iteration tree building - for large boid counts, do more iterations
    int iterations = numBoids > 50000 ? 6 : 3; // Do more iterations for high boid counts
    for (int iteration = 0; iteration < iterations; iteration++) {
        // PHASE 5A: Subdivide nodes
        bool didSubdivide = false;
        if (id.x < MaxQuadNodes) {
            QuadNode node = quadNodes[id.x];
            bool isLeaf = (node.flags & NODE_LEAF) != 0;
            bool isActive = (node.flags & NODE_ACTIVE) != 0;
            
            // Only process active leaf nodes that need subdivision
            if (isLeaf && isActive && node.count > maxBoidsPerNode) {
                uint currentNodeCount;
                InterlockedAdd(nodeCount[0], 0, currentNodeCount);
                
                // Check if there's room for 4 more nodes
                if (currentNodeCount + 4 <= MaxQuadNodes && node.size > 2.0) {
                    // Allocate children
                    uint childIndex;
                    InterlockedAdd(nodeCount[0], 4, childIndex);
                    
                    if (childIndex + 4 <= MaxQuadNodes) {
                        // Update parent node
                        node.childIndex = childIndex;
                        node.flags &= ~NODE_LEAF;  // Clear leaf flag
                        quadNodes[id.x] = node;
                        didSubdivide = true;
                        
                        // Create children
                        float childSize = node.size * 0.5;
                        for (uint i = 0; i < 4; i++) {
                            // Position the child at the correct quadrant
                            // For proper tiling without gaps or overlaps, we need a full childSize offset
                            float offsetX = (i & 1) ? -childSize : childSize;
                            float offsetY = (i & 2) ? -childSize : childSize;
                            
                            QuadNode child;
                            child.center = node.center + float2(offsetX, offsetY);
                            child.size = childSize;
                            child.childIndex = 0;
                            child.startIndex = 0;
                            child.count = 0;
                            child.flags = NODE_LEAF | NODE_ACTIVE;
                            
                            // Write child node
                            quadNodes[childIndex + i] = child;
                            
                            // Add to active nodes list
                            uint newActiveIdx;
                            InterlockedAdd(activeNodeCount[0], 1, newActiveIdx);
                            
                            if (newActiveIdx < MaxQuadNodes) {
                                activeNodes[newActiveIdx] = childIndex + i;
                            }
                        }
                    }
                }
            }
        }
        
        // Ensure all subdivisions complete before redistribution
        DeviceMemoryBarrier();
        
        // PHASE 5B: Redistribute boids - All threads within numBoids participate
        if (id.x < numBoids) {
            uint boidIndex = boidIndices[id.x * 2];
            uint nodeIndex = boidIndices[id.x * 2 + 1];
            
            Boid boid = boids[boidIndex];
            QuadNode node = quadNodes[nodeIndex];
            
            // ESSENTIAL FIX: We need to find the correct leaf node for this boid
            // Start from current node but traverse down to a leaf
            uint currentNodeIndex = nodeIndex;
            QuadNode currentNode = node;
            
            // Keep traversing down the tree until we reach a leaf node
            while ((currentNode.flags & NODE_LEAF) == 0 && currentNode.childIndex > 0) {
                // Determine which quadrant this boid belongs to
                uint quadrant = 0;
                if (boid.pos.x < currentNode.center.x) quadrant |= 1; // West
                if (boid.pos.y < currentNode.center.y) quadrant |= 2; // South
                
                // Calculate child node index
                uint childIndex = currentNode.childIndex + quadrant;
                
                // Safety check to avoid infinite loops or invalid indices
                if (childIndex >= MaxQuadNodes || childIndex == currentNodeIndex) {
                    break;
                }
                
                // Decrement count in current node before moving down
                InterlockedAdd(nodeCounts[currentNodeIndex], -1);
                
                // Move to child node
                currentNodeIndex = childIndex;
                currentNode = quadNodes[currentNodeIndex];
            }
            
            // If we found a different node than the original, update assignments
            if (currentNodeIndex != nodeIndex) {
                // Update node assignment in boid indices
                boidIndices[id.x * 2 + 1] = currentNodeIndex;
                
                // Update the history record to maintain consistency
                BoidWithHistory boidHist = boidHistory[boidIndex];
                boidHist.nodeIndex = currentNodeIndex;
                boidHistory[boidIndex] = boidHist;
                
                // Update count in the final node
                InterlockedAdd(nodeCounts[currentNodeIndex], 1);
            }
        }
        
        // Ensure all redistributions complete before updating node counts
        DeviceMemoryBarrier();
        
        // PHASE 5C: Update node counts - All threads within MaxQuadNodes participate
        if (id.x < MaxQuadNodes) {
            QuadNode node = quadNodes[id.x];
            node.count = nodeCounts[id.x];
            quadNodes[id.x] = node;
        }
        
        // Ensure node counts are updated before next iteration
        DeviceMemoryBarrier();
        
        // PHASE 5D: Every other iteration, update boid history to match the current assignment
        // This helps ensure consistency between boidIndices and boidHistory
        if ((uint)iteration % 2u == 1u && id.x < numBoids) {
            uint boidIdx = boidIndices[id.x * 2];
            uint nodeIdx = boidIndices[id.x * 2 + 1];
            
            // Update the history record to match current node assignment
            BoidWithHistory boidHist = boidHistory[boidIdx];
            if (boidHist.nodeIndex != nodeIdx) {
                boidHist.nodeIndex = nodeIdx;
                boidHistory[boidIdx] = boidHist;
            }
        }
        
        // Ensure boid history updates are complete before next iteration
        DeviceMemoryBarrier();
    }
    
    // PHASE 6: Sort boids based on their node assignments
    // First, clear output buffer to avoid invalid data
    if (id.x < numBoids) {
        // Set default value
        boidsOut[id.x] = boids[0]; // Default value
    }
    
    // Ensure clear is complete
    DeviceMemoryBarrier();
    
    // Then perform the actual sort
    if (id.x < numBoids) {
        uint boidIdx = boidIndices[id.x * 2];
        if (boidIdx < numBoids) {
            boidsOut[id.x] = boids[boidIdx];
        }
    }
}