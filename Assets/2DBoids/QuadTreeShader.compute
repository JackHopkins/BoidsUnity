// Optimized Quad-tree implementation for boid simulation
#define blockSize 256  // Reduced from 1024 to 256 for better occupancy
#define NODE_LEAF 1
#define NODE_ACTIVE 2
#define MaxQuadNodes 65536  // Increased from 16384 to 65536 for high boid counts
#define BOUNDARY_THRESHOLD 0.1  // Fraction of quad size to consider "near boundary" (reduced from 0.2)
#define VELOCITY_FRAMES_AHEAD 1.5 // How many frames ahead to project velocity (reduced from 3.0)
#define HIGH_BOID_COUNT_THRESHOLD 25000 // Threshold to activate high-performance optimizations

struct Boid {
    float2 pos;
    float2 vel;
    uint team;
};

struct BoidWithHistory {
    float2 pos;      // Current position
    float2 prevPos;  // Previous position for tracking movement
    float2 vel;
    uint team;
    uint nodeIndex;  // Current quadtree node index
};

struct QuadNode {
    float2 center;
    float size;
    uint childIndex;    // Index of first child (other children are at +1, +2, +3)
    uint startIndex;    // Start index of boids in this node
    uint count;         // Number of boids in this node
    uint flags;         // Bit flags: 1=leaf, 2=active, etc.
};

// Input/output buffers
RWStructuredBuffer<QuadNode> quadNodes;
RWStructuredBuffer<uint> nodeCount;          // Single element counter
RWStructuredBuffer<uint> activeNodeCount;    // Single element counter
RWStructuredBuffer<uint> activeNodes;        // List of active node indices
RWStructuredBuffer<uint> boidIndices;        // Maps from quadtree order to boid index
StructuredBuffer<Boid> boids;                // Original boids
RWStructuredBuffer<Boid> boidsOut;           // Reordered boids
RWStructuredBuffer<uint> nodeCounts;         // Dedicated buffer for atomic counting
RWStructuredBuffer<BoidWithHistory> boidHistory; // Tracks boid history for incremental updates
RWStructuredBuffer<uint> movedBoidIndices;   // Indices of boids that moved significantly
RWStructuredBuffer<uint> movedBoidCount;     // Number of boids that moved significantly

// Parameters
uint maxDepth;             // Maximum depth of the quad-tree
uint maxBoidsPerNode;      // Maximum boids per leaf node before subdivision
uint numBoids;             // Total number of boids
float worldSize;           // Size of the world (half-width)
float deltaTime;           // Time since last frame

// Determine which quadrant a point belongs to (0=NE, 1=NW, 2=SW, 3=SE)
uint GetQuadrant(float2 center, float2 pos) {
    uint quadrant = 0;
    if (pos.x < center.x) quadrant |= 1;
    if (pos.y < center.y) quadrant |= 2;
    return quadrant;
}

// Get child center based on parent center and quadrant
float2 GetChildCenter(float2 parentCenter, float parentSize, uint quadrant) {
    // Calculate child size (half of parent size)
    float childSize = parentSize * 0.5;
    
    // For proper quadtree tiling:
    // - Each child needs to be placed at a full childSize offset from the parent center
    // - This ensures the child's edge aligns with the parent center, properly tiling the space
    float offsetX = (quadrant & 1) ? -childSize : childSize;
    float offsetY = (quadrant & 2) ? -childSize : childSize;
    
    return parentCenter + float2(offsetX, offsetY);
}

#pragma kernel InitializeQuadTree
[numthreads(blockSize, 1, 1)]
void InitializeQuadTree(uint3 id : SV_DispatchThreadID) {
    // Thread 0 initializes the core structures
    if (id.x == 0) {
        // Always reset to a clean state with just one root node
        nodeCount[0] = 1;
        activeNodeCount[0] = 1;
        
        // Initialize root node as a leaf
        QuadNode root;
        root.center = float2(0, 0);
        root.size = worldSize;
        root.childIndex = 0;  // No children initially
        root.startIndex = 0;
        root.count = 0;
        root.flags = NODE_LEAF | NODE_ACTIVE;  // Must be a leaf to start
        
        quadNodes[0] = root;
        activeNodes[0] = 0;
    }
    
    // All threads clear node counts in parallel
    if (id.x < MaxQuadNodes) {
        // Clear all node counts
        nodeCounts[id.x] = 0;
        
        // For nodes other than root, reset completely
        if (id.x > 0) {
            QuadNode node;
            node.center = float2(0, 0);
            node.size = 0;
            node.childIndex = 0;
            node.startIndex = 0;
            node.count = 0;
            node.flags = 0;  // Inactive and not a leaf
            
            quadNodes[id.x] = node;
        }
    }
}

// OPTIMIZATION: This legacy kernel is kept for compatibility but can be removed
#pragma kernel ClearQuadTree
[numthreads(1, 1, 1)]
void ClearQuadTree() {
    // Reset counters
    nodeCount[0] = 1;
    activeNodeCount[0] = 1;
    
    // Initialize root node
    QuadNode root;
    root.center = float2(0, 0);
    root.size = worldSize;
    root.childIndex = 0;
    root.startIndex = 0;
    root.count = 0;
    root.flags = NODE_LEAF | NODE_ACTIVE;
    
    quadNodes[0] = root;
    activeNodes[0] = 0;
}

// OPTIMIZATION: Legacy support for backward compatibility
#pragma kernel ActivateRoot
[numthreads(1, 1, 1)]
void ActivateRoot() {
    // Only needed if not using InitializeQuadTree
    QuadNode root = quadNodes[0];
    root.flags |= NODE_ACTIVE;
    quadNodes[0] = root;
    activeNodeCount[0] = 1;
    activeNodes[0] = 0;
}

// Initialize boid history buffer - used when we first create the quadtree
#pragma kernel InitializeBoidHistory
[numthreads(blockSize, 1, 1)]
void InitializeBoidHistory(uint3 id : SV_DispatchThreadID) {
    if (id.x >= numBoids) return;
    
    // Get current boid
    Boid boid = boids[id.x];
    
    // Create history entry with current position as both current and previous
    BoidWithHistory boidHist;
    boidHist.pos = boid.pos;
    boidHist.prevPos = boid.pos; // Initialize previous pos to current
    boidHist.vel = boid.vel;
    boidHist.team = boid.team;
    boidHist.nodeIndex = 0; // Default to root node
    
    // Write to history buffer
    boidHistory[id.x] = boidHist;
    
    // Reset moved boid count on first thread
    if (id.x == 0) {
        movedBoidCount[0] = 0;
    }
}

// Insert boids into the quadtree (kernel 1)
#pragma kernel InsertBoids
[numthreads(blockSize, 1, 1)]
void InsertBoids(uint3 id : SV_DispatchThreadID) {
    if (id.x >= numBoids) return;
    
    // Assign all boids to the root node initially
    boidIndices[id.x * 2] = id.x;     // Original boid index
    boidIndices[id.x * 2 + 1] = 0;     // Assigned to root node
    
    // Count boids in root node using atomic increment
    InterlockedAdd(nodeCounts[0], 1);
}


// OPTIMIZATION: Update node counts from the atomic counters
#pragma kernel UpdateNodeCounts
[numthreads(blockSize, 1, 1)]
void UpdateNodeCounts(uint3 id : SV_DispatchThreadID) {
    uint totalNodes;
    InterlockedAdd(nodeCount[0], 0, totalNodes);
    
    if (id.x >= totalNodes) return;
    
    // Copy count from nodeCounts to the node structure
    QuadNode node = quadNodes[id.x];
    node.count = nodeCounts[id.x];
    quadNodes[id.x] = node;
}

// OPTIMIZATION: Clear node counts efficiently
#pragma kernel ClearNodeCounts
[numthreads(blockSize, 1, 1)]
void ClearNodeCounts(uint3 id : SV_DispatchThreadID) {
    if (id.x >= MaxQuadNodes) return;
    
    // Reset all node counts
    nodeCounts[id.x] = 0;
}

// OPTIMIZATION: Sort boids using quadtree structure with better memory access
#pragma kernel SortBoids
[numthreads(blockSize, 1, 1)]
void SortBoids(uint3 id : SV_DispatchThreadID) {
    if (id.x >= numBoids) return;
    
    // Get the boid index from quadtree order
    uint boidIdx = boidIndices[id.x * 2];
    
    // Safety check
    if (boidIdx >= numBoids) return;
    
    // Read once, write once for better memory performance
    Boid boid = boids[boidIdx];
    boidsOut[id.x] = boid;
}


#pragma kernel DiagnoseSubdivision
RWStructuredBuffer<uint> diagData;

[numthreads(1, 1, 1)]
void DiagnoseSubdivision() {
    // Get the root node for analysis
    QuadNode rootNode = quadNodes[0];
    
    // 1. Check leaf flag
    bool isLeaf = (rootNode.flags & NODE_LEAF) != 0;
    diagData[0] = isLeaf ? 1 : 0;
    
    // 2. Check count vs threshold
    bool countExceedsThreshold = rootNode.count > maxBoidsPerNode;
    diagData[1] = countExceedsThreshold ? 1 : 0;
    
    // 3. Check node count limit
    bool hasSpaceForChildren = nodeCount[0] < (MaxQuadNodes - 4);
    diagData[2] = hasSpaceForChildren ? 1 : 0;
    
    // 4. Check size threshold
    bool sizeAboveThreshold = rootNode.size > 2.0;
    diagData[3] = sizeAboveThreshold ? 1 : 0;
    
    // Store actual values for reference
    diagData[4] = rootNode.flags;
    diagData[5] = rootNode.count;
    diagData[6] = maxBoidsPerNode;
    diagData[7] = nodeCount[0];
    diagData[8] = (uint)rootNode.size;
    
    // Store a distinct marker to verify this kernel ran
    diagData[9] = 0xDEADBEEF;
}

#pragma kernel ForceRedistributeRootBoids
[numthreads(256, 1, 1)]
void ForceRedistributeRootBoids(uint3 id : SV_DispatchThreadID) {
    if (id.x >= numBoids) return;
    
    // Get boid info
    uint boidIndex = boidIndices[id.x * 2];
    uint nodeIndex = boidIndices[id.x * 2 + 1];
    
    // Only process boids in the root node
    if (nodeIndex != 0) return;
    
    // Get the root node
    QuadNode rootNode = quadNodes[0];
    
    // Only proceed if root has children and is not a leaf
    if ((rootNode.flags & NODE_LEAF) != 0 || rootNode.childIndex <= 0 || rootNode.childIndex >= MaxQuadNodes) 
        return;
    
    // Get the boid position
    Boid boid = boids[boidIndex];
    
    // Calculate which quadrant this boid belongs to
    uint quadrant = 0;
    if (boid.pos.x < rootNode.center.x) quadrant |= 1; // west
    if (boid.pos.y < rootNode.center.y) quadrant |= 2; // south
    
    // Calculate child node index
    uint childIndex = rootNode.childIndex + quadrant;
    
    // Make sure child index is valid
    if (childIndex >= MaxQuadNodes) return;
    
    // Force-update the boid's node assignment
    boidIndices[id.x * 2 + 1] = childIndex;
}

// OPTIMIZATION: Combined operation for subdividing and redistributing
#pragma kernel SubdivideAndRedistribute
[numthreads(blockSize, 1, 1)]
void SubdivideAndRedistribute(uint3 id : SV_DispatchThreadID) {
    // PHASE 1: Subdivision phase - separate from redistribution
    uint totalActiveNodes;
    InterlockedAdd(activeNodeCount[0], 0, totalActiveNodes);
    
    // All threads participate in sync barriers regardless of flow path
    bool canSubdivide = false;
    uint nodeIndex = 0;
    QuadNode node;
    
    if (id.x < totalActiveNodes) {
        nodeIndex = activeNodes[id.x];
        node = quadNodes[nodeIndex];
        
        // Check subdivision conditions without early exit
        bool isLeaf = (node.flags & NODE_LEAF) != 0;
        bool exceededThreshold = node.count > maxBoidsPerNode;
        bool hasSpace = nodeCount[0] < MaxQuadNodes - 4;
        bool sizeOK = node.size > 2.0;
        
        canSubdivide = isLeaf && exceededThreshold && hasSpace && sizeOK;
    }
    
    // All threads must reach this barrier
    DeviceMemoryBarrier();
    
    // Only threads that need to subdivide continue with subdivision
    uint childIndex = 0;
    if (canSubdivide) {
        // Allocate children
        InterlockedAdd(nodeCount[0], 4, childIndex);
        
        if (childIndex + 4 < MaxQuadNodes) {
            // Update parent
            node.childIndex = childIndex;
            node.flags &= ~NODE_LEAF;
            quadNodes[nodeIndex] = node;
            
            // Create children
            float childSize = node.size * 0.5;
            for (uint i = 0; i < 4; i++) {
                uint qx = i & 1; // 0 for east, 1 for west
                uint qy = (i & 2) >> 1; // 0 for north, 1 for south
                
                // Position the child at the correct quadrant
                // For proper tiling without gaps or overlaps, we need a full childSize offset
                float offsetX = (qx == 0) ? childSize : -childSize;
                float offsetY = (qy == 0) ? childSize : -childSize;
                
                QuadNode child;
                child.center = node.center + float2(offsetX, offsetY);
                child.size = childSize;
                child.childIndex = 0;
                child.startIndex = 0;
                child.count = 0;
                child.flags = NODE_LEAF | NODE_ACTIVE;
                
                quadNodes[childIndex + i] = child;
                
                uint activeIdx;
                InterlockedAdd(activeNodeCount[0], 1, activeIdx);
                
                if (activeIdx < MaxQuadNodes) {
                    activeNodes[activeIdx] = childIndex + i;
                }
            }
        }
    }
    
    // All threads must reach this barrier before redistribution begins
    DeviceMemoryBarrier();
    
    // PHASE A: First, clear out node counts for accurate recounting
    if (id.x < MaxQuadNodes) {
        nodeCounts[id.x] = 0;
    }
    
    // Ensure all threads complete the clearing
    DeviceMemoryBarrier();
    
    // PHASE B: Assign each boid to its appropriate node
    if (id.x < numBoids) {
        uint boidIndex = boidIndices[id.x * 2];
        Boid boid = boids[boidIndex];
        
        // Start from root node (index 0) for consistent traversal
        uint currentNodeIndex = 0;
        QuadNode currentNode = quadNodes[currentNodeIndex];
        
        // Traverse the tree to find the correct leaf node for this boid
        while ((currentNode.flags & NODE_LEAF) == 0 && currentNode.childIndex > 0) {
            // Determine quadrant
            uint quadrant = 0;
            quadrant |= (boid.pos.x < currentNode.center.x) ? 1 : 0;
            quadrant |= (boid.pos.y < currentNode.center.y) ? 2 : 0;
            
            // Move to child node
            uint newNodeIndex = currentNode.childIndex + quadrant;
            
            // Safety check to avoid infinite loops
            if (newNodeIndex >= MaxQuadNodes || newNodeIndex == currentNodeIndex) {
                break;
            }
            
            currentNodeIndex = newNodeIndex;
            currentNode = quadNodes[currentNodeIndex];
        }
        
        // Update boid assignment
        boidIndices[id.x * 2 + 1] = currentNodeIndex;
        
        // Increment the node count for this node
        InterlockedAdd(nodeCounts[currentNodeIndex], 1);
    }
    
    // Ensure all boids are assigned before updating node counts
    DeviceMemoryBarrier();
    
    // PHASE C: Update node counts from the nodeCounts buffer
    if (id.x < MaxQuadNodes) {
        QuadNode updatedNode = quadNodes[id.x];
        updatedNode.count = nodeCounts[id.x];
        quadNodes[id.x] = updatedNode;
    }
}

#pragma kernel ResetRootNode
[numthreads(1, 1, 1)]
void ResetRootNode() {
    // Reset just the root node to ensure it starts as a leaf
    QuadNode root;
    root.center = float2(0, 0);
    root.size = worldSize;
    root.childIndex = 0;  // No children
    root.startIndex = 0;
    root.count = 0;
    root.flags = NODE_LEAF | NODE_ACTIVE;  // Force LEAF flag
    
    quadNodes[0] = root;
    nodeCount[0] = 1;  // Reset to just one node
    activeNodeCount[0] = 1;
    activeNodes[0] = 0;
}

// Collapse empty or near-empty nodes back into their parent
#pragma kernel CollapseNodes
[numthreads(blockSize, 1, 1)]
void CollapseNodes(uint3 id : SV_DispatchThreadID) {
    // Get total active nodes to process
    uint totalActiveNodes;
    InterlockedAdd(activeNodeCount[0], 0, totalActiveNodes);
    
    // Only process active nodes
    if (id.x >= totalActiveNodes) return;
    
    // Get the active node index
    uint nodeIndex = activeNodes[id.x];
    QuadNode node = quadNodes[nodeIndex];
    
    // Skip if this is not a non-leaf node that wants to collapse
    if ((node.flags & NODE_LEAF) != 0 || node.count >= (maxBoidsPerNode / 4)) return;
    
    // Check if all children are leaves with few boids in total
    bool canCollapse = true;
    uint totalChildBoids = 0;
    uint totalNodes;
    InterlockedAdd(nodeCount[0], 0, totalNodes);
    
    // Skip if no valid children
    if (node.childIndex <= 0 || node.childIndex >= totalNodes) return;
    
    // Check each child
    for (uint i = 0; i < 4; i++) {
        uint childIdx = node.childIndex + i;
        if (childIdx >= totalNodes) continue;
        
        QuadNode child = quadNodes[childIdx];
        totalChildBoids += child.count;
        
        // If any child is not a leaf, we can't collapse
        if ((child.flags & NODE_LEAF) == 0) {
            canCollapse = false;
            break;
        }
    }
    
    // Only collapse if all children together have few enough boids
    if (canCollapse && totalChildBoids < maxBoidsPerNode) {
        // Turn this node back into a leaf
        node.flags |= NODE_LEAF;
        
        // Skip the expensive O(n²) loop for high boid counts
        // For high boid counts, we'll handle this differently - boids will be automatically
        // reclassified when they next move significantly
        if (numBoids < HIGH_BOID_COUNT_THRESHOLD) {
            // Redistribute all boids from children to this node - ONLY for small boid counts
            for (uint j = 0; j < numBoids; j++) {
                uint boidNodeIndex = boidIndices[j * 2 + 1];
                
                // Check if this boid is in one of the children
                bool inChild = false;
                for (uint k = 0; k < 4; k++) {
                    uint childIdx = node.childIndex + k;
                    if (boidNodeIndex == childIdx) {
                        inChild = true;
                        break;
                    }
                }
                
                if (inChild) {
                    // Move boid to this node
                    boidIndices[j * 2 + 1] = nodeIndex;
                    
                    // Update history
                    BoidWithHistory boidHist = boidHistory[j];
                    boidHist.nodeIndex = nodeIndex;
                    boidHistory[j] = boidHist;
                }
            }
        } else {
            // For high boid counts, just flag the boids in these nodes to be recalculated
            // next time they're processed in TrackMovedBoids - much more efficient
            for (uint k = 0; k < 4; k++) {
                uint childIdx = node.childIndex + k;
                if (childIdx < totalNodes) {
                    quadNodes[childIdx].flags |= 0x10; // Special flag to mark as needing reclassification
                }
            }
        }
        
        // Update the node count
        node.count = totalChildBoids;
        nodeCounts[nodeIndex] = totalChildBoids;
        
        // Set child nodes as inactive
        for (uint m = 0; m < 4; m++) {
            uint childIdx = node.childIndex + m;
            if (childIdx < totalNodes) {
                QuadNode child = quadNodes[childIdx];
                child.count = 0;
                child.flags &= ~NODE_ACTIVE;  // Clear active flag
                quadNodes[childIdx] = child;
                nodeCounts[childIdx] = 0;
            }
        }
        
        // Mark children as available for reuse by clearing childIndex
        // but keep the reference for later cleanup if needed
        // node.childIndex = 0;
        
        // Write back the updated node
        quadNodes[nodeIndex] = node;
    }
}

#pragma kernel RecountBoids
[numthreads(blockSize, 1, 1)]
void RecountBoids(uint3 id : SV_DispatchThreadID) {
    if (id.x >= numBoids) return;
    
    // Get the node this boid is assigned to
    uint nodeIndex = boidIndices[id.x * 2 + 1];
    
    // Increment the count for this node
    if (nodeIndex < MaxQuadNodes) {
        InterlockedAdd(nodeCounts[nodeIndex], 1);
    }
}



#pragma kernel DebugSubdivision
RWStructuredBuffer<uint> subdivDebug;  // Add this buffer

[numthreads(1, 1, 1)]
void DebugSubdivision() {
    // Check root node
    QuadNode root = quadNodes[0];
    
    // Output debug info
    subdivDebug[0] = root.flags;  // Should have NODE_LEAF bit set
    subdivDebug[1] = root.count;  // Should be > maxBoidsPerNode
    subdivDebug[2] = nodeCount[0]; // Current node count
    subdivDebug[3] = MaxQuadNodes - 4; // Max nodes threshold
    subdivDebug[4] = (uint)(root.size); // Root size
    subdivDebug[5] = maxBoidsPerNode; // Threshold
    subdivDebug[6] = activeNodeCount[0]; // Should be 1 initially
    
    // Individual condition checks (1 = pass, 0 = fail)
    subdivDebug[7] = (root.flags & NODE_LEAF) != 0 ? 1 : 0; // is leaf?
    subdivDebug[8] = root.count > maxBoidsPerNode ? 1 : 0; // exceeds threshold?
    subdivDebug[9] = nodeCount[0] < MaxQuadNodes - 4 ? 1 : 0; // room for children?
}

#pragma kernel TestMaxBoidsPerNode
RWStructuredBuffer<uint> testBuffer;

[numthreads(1, 1, 1)]
void TestMaxBoidsPerNode() {
    // Simply copy the value directly
    testBuffer[0] = maxBoidsPerNode;
}

// Track which boids are likely to cross a quadtree boundary
#pragma kernel TrackMovedBoids
[numthreads(blockSize, 1, 1)]
void TrackMovedBoids(uint3 id : SV_DispatchThreadID) {
    if (id.x >= numBoids) return;
    
    // Reset the moved boid count for first thread
    if (id.x == 0) {
        movedBoidCount[0] = 0;
    }
    
    // Ensure the count is initialized before proceeding
    DeviceMemoryBarrier();
    
    // Get current boid data
    Boid currentBoid = boids[id.x];
    BoidWithHistory boidHist = boidHistory[id.x];
    
    // Skip most processing for high boid counts to improve performance
    bool isHighBoidCount = numBoids > HIGH_BOID_COUNT_THRESHOLD;
    
    // Get the current node this boid belongs to
    uint nodeIndex = boidHist.nodeIndex;
    bool needsUpdate = false;
    
    // Check if the node index is valid
    if (nodeIndex < MaxQuadNodes) {
        // Optimization: For high boid counts, check the most critical cases only
        // 1. First check if it's outside its current node which is the most common case
        // 2. Only if it's within the node, check for reclassification flag
        
        QuadNode node = quadNodes[nodeIndex];
        
        // Simple position check first (most efficient)
        float2 boidPos = currentBoid.pos;
        float nodeSize = node.size;
        float2 nodeCenter = node.center;
        
        bool outsideQuad = 
            boidPos.x < (nodeCenter.x - nodeSize) || 
            boidPos.x > (nodeCenter.x + nodeSize) ||
            boidPos.y < (nodeCenter.y - nodeSize) || 
            boidPos.y > (nodeCenter.y + nodeSize);
        
        if (outsideQuad) {
            needsUpdate = true;
        }
        // Only do more expensive flag check if not already marked for update
        else if ((node.flags & 0x10) != 0) {
            needsUpdate = true;
        }
        else {
            float2 boidVel = currentBoid.vel;
            
            // For high boid counts, we already checked if outside quad - just need boundary checks
            if (numBoids > HIGH_BOID_COUNT_THRESHOLD) {
                // We already did the outside quad check above
                needsUpdate = false;
            }
            else {
                // Detailed check for lower boid counts - check boundaries and velocity
                // Calculate distance from boid to each boundary of its quad
                float distToLeftBoundary = boidPos.x - (nodeCenter.x - nodeSize);
                float distToRightBoundary = (nodeCenter.x + nodeSize) - boidPos.x;
                float distToBottomBoundary = boidPos.y - (nodeCenter.y - nodeSize);
                float distToTopBoundary = (nodeCenter.y + nodeSize) - boidPos.y;
                
                // Calculate threshold distance based on node size
                float boundaryThreshold = nodeSize * BOUNDARY_THRESHOLD;
                
                // Project the boid's position forward based on velocity
                float2 projectedPos = boidPos + (boidVel * deltaTime * VELOCITY_FRAMES_AHEAD);
                
                // Check if the boid is:
                // 1. Near the left boundary AND moving left
                // 2. Near the right boundary AND moving right
                // 3. Near the bottom boundary AND moving down
                // 4. Near the top boundary AND moving up
                bool nearLeftAndMovingLeft = distToLeftBoundary < boundaryThreshold && boidVel.x < 0;
                bool nearRightAndMovingRight = distToRightBoundary < boundaryThreshold && boidVel.x > 0;
                bool nearBottomAndMovingDown = distToBottomBoundary < boundaryThreshold && boidVel.y < 0;
                bool nearTopAndMovingUp = distToTopBoundary < boundaryThreshold && boidVel.y > 0;
                
                // Also check if the projected position would be outside the current quad
                bool projectedOutsideQuad = 
                    projectedPos.x < (nodeCenter.x - nodeSize) || 
                    projectedPos.x > (nodeCenter.x + nodeSize) ||
                    projectedPos.y < (nodeCenter.y - nodeSize) || 
                    projectedPos.y > (nodeCenter.y + nodeSize);
                
                // Flag boid as needing update if it's near a boundary and moving toward it,
                // or if it's projected to leave the quad soon
                needsUpdate = nearLeftAndMovingLeft || nearRightAndMovingRight || 
                            nearBottomAndMovingDown || nearTopAndMovingUp ||
                            projectedOutsideQuad;
            }
        }
    } else {
        // If the node index is invalid, force an update
        needsUpdate = true;
    }
    
    // Add to moved boids list if it needs update
    if (needsUpdate) {
        uint index;
        InterlockedAdd(movedBoidCount[0], 1, index);
        
        // Record this boid's index in the moved list
        if (index < numBoids) {
            movedBoidIndices[index] = id.x;
        }
    }
    
    // Always update the history
    boidHist.prevPos = boidHist.pos;
    boidHist.pos = currentBoid.pos;
    boidHist.vel = currentBoid.vel;
    boidHist.team = currentBoid.team;
    // Keep the current node assignment
    
    // Write back to history buffer
    boidHistory[id.x] = boidHist;
}

// OPTIMIZATION: This is a test/debug kernel that manually subdivides just the root
#pragma kernel TestSubdivide
[numthreads(1, 1, 1)]
void TestSubdivide() {
    // Manually subdivide the root - useful for testing
    QuadNode root = quadNodes[0];
    root.childIndex = 1;
    root.flags &= ~NODE_LEAF;
    
    for (uint i = 0; i < 4; i++) {
        QuadNode child;
        child.center = GetChildCenter(root.center, root.size, i);
        child.size = root.size * 0.5;
        child.childIndex = 0;
        child.startIndex = 0;
        child.count = 0;
        child.flags = NODE_LEAF | NODE_ACTIVE;
        
        quadNodes[1 + i] = child;
    }
    
    quadNodes[0] = root;
    nodeCount[0] = 5;
}

// OPTIMIZATION: This kernel doesn't need to be changed - keeping it for backward compatibility
#pragma kernel CountBoids
[numthreads(blockSize, 1, 1)]
void CountBoids(uint3 id : SV_DispatchThreadID) {
    if (id.x >= numBoids) return;
    
    // Always assign to root for now
    uint nodeIndex = 0;
    
    // Store boid index and node
    boidIndices[id.x * 2] = id.x;
    boidIndices[id.x * 2 + 1] = nodeIndex;
}

// OPTIMIZATION: This kernel doesn't need to be changed - keeping it for backward compatibility
#pragma kernel SumNodeCounts
[numthreads(1, 1, 1)]
void SumNodeCounts() {
    // Reset count
    QuadNode root = quadNodes[0];
    root.count = 0;
    
    // Count all boids assigned to root
    for (uint i = 0; i < numBoids; i++) {
        uint nodeIndex = boidIndices[i * 2 + 1];
        if (nodeIndex == 0) {
            root.count++;
        }
    }
    
    // Write back
    quadNodes[0] = root;
}

// Incremental update of quadtree - only process boids that moved significantly
#pragma kernel IncrementalQuadTreeUpdate
[numthreads(blockSize, 1, 1)]
void IncrementalQuadTreeUpdate(uint3 id : SV_DispatchThreadID) {
    // Get the number of boids that moved significantly
    uint numMovedBoids = movedBoidCount[0];
    
    // Only process if this thread maps to a moved boid
    if (id.x >= numMovedBoids) return;
    
    // Get the actual boid index from the moved list
    uint boidIndex = movedBoidIndices[id.x];
    
    // Get the boid's current data
    Boid boid = boids[boidIndex];
    BoidWithHistory boidHist = boidHistory[boidIndex];
    
    // Get the current node assignment
    uint oldNodeIndex = boidHist.nodeIndex;
    
    // Start traversal from the root to find the new node
    uint newNodeIndex = 0;
    QuadNode currentNode = quadNodes[newNodeIndex];
    
    // Traverse to find the leaf node for this boid
    while ((currentNode.flags & NODE_LEAF) == 0 && currentNode.childIndex > 0) {
        // Determine which quadrant the boid belongs to
        uint quadrant = 0;
        if (boid.pos.x < currentNode.center.x) quadrant |= 1; // west
        if (boid.pos.y < currentNode.center.y) quadrant |= 2; // south
        
        // Calculate index of the child node for this quadrant
        uint childIndex = currentNode.childIndex + quadrant;
        
        // Safety check
        if (childIndex >= MaxQuadNodes || childIndex == newNodeIndex) {
            break;
        }
        
        // Move to the child node
        newNodeIndex = childIndex;
        currentNode = quadNodes[newNodeIndex];
    }
    
    // Only update if the boid has moved to a new node
    if (oldNodeIndex != newNodeIndex) {
        // Remove from old node (atomic to avoid race conditions)
        if (oldNodeIndex < MaxQuadNodes) {
            InterlockedAdd(nodeCounts[oldNodeIndex], -1);
        }
        
        // Add to new node (atomic to avoid race conditions)
        InterlockedAdd(nodeCounts[newNodeIndex], 1);
        
        // Update boid's node index
        boidIndices[boidIndex * 2 + 1] = newNodeIndex;
        boidHist.nodeIndex = newNodeIndex;
        boidHistory[boidIndex] = boidHist;
    }
}

// Check if nodes need to be subdivided or merged based on the updated counts
#pragma kernel RepairTreeStructure
[numthreads(blockSize, 1, 1)]
void RepairTreeStructure(uint3 id : SV_DispatchThreadID) {
    // Get total node count
    uint totalNodes;
    InterlockedAdd(nodeCount[0], 0, totalNodes);
    
    if (id.x >= totalNodes) return;
    
    // Copy node counts to the actual node structures
    QuadNode node = quadNodes[id.x];
    node.count = nodeCounts[id.x];
    
    // If this is a leaf node and exceeds threshold, mark as active for subdivision
    if ((node.flags & NODE_LEAF) != 0 && node.count > maxBoidsPerNode) {
        // Mark as active
        node.flags |= NODE_ACTIVE;
        
        // Add to active nodes list
        uint activeIdx;
        InterlockedAdd(activeNodeCount[0], 1, activeIdx);
        
        if (activeIdx < MaxQuadNodes) {
            activeNodes[activeIdx] = id.x;
        }
    }
    // If this is a parent node with very few boids (potentially after boids moved away),
    // consider collapsing it back to a leaf - by marking it active
    else if ((node.flags & NODE_LEAF) == 0 && node.count < (maxBoidsPerNode / 4) && 
             node.childIndex > 0 && node.childIndex < totalNodes) {
        // Check if all children are leaves and have few boids
        bool canCollapse = true;
        uint totalChildBoids = 0;
        
        for (uint i = 0; i < 4; i++) {
            uint childIdx = node.childIndex + i;
            if (childIdx >= totalNodes) continue;
            
            QuadNode child = quadNodes[childIdx];
            totalChildBoids += child.count;
            
            // If any child is not a leaf, we can't collapse
            if ((child.flags & NODE_LEAF) == 0) {
                canCollapse = false;
                break;
            }
        }
        
        // Only collapse if all children together have few boids
        if (canCollapse && totalChildBoids < maxBoidsPerNode) {
            // Mark as active for potential collapse
            node.flags |= NODE_ACTIVE;
            
            // Add to active nodes list for processing
            uint activeIdx;
            InterlockedAdd(activeNodeCount[0], 1, activeIdx);
            
            if (activeIdx < MaxQuadNodes) {
                activeNodes[activeIdx] = id.x;
            }
        }
    }
    
    // Write back node with potentially updated flags
    quadNodes[id.x] = node;
}

#pragma kernel BuildQuadtreeUnified
[numthreads(blockSize, 1, 1)]
void BuildQuadtreeUnified(uint3 id : SV_DispatchThreadID) {
    // PHASE 1: Initialize - Thread 0 handles single-instance initialization
    if (id.x == 0) {
        // Reset node count and active nodes
        nodeCount[0] = 1;
        activeNodeCount[0] = 1;
        
        // Initialize root as a leaf node
        QuadNode root;
        root.center = float2(0, 0);
        root.size = worldSize;
        root.childIndex = 0;
        root.startIndex = 0;
        root.count = 0;
        root.flags = NODE_LEAF | NODE_ACTIVE;
        
        quadNodes[0] = root;
        activeNodes[0] = 0;
    }
    
    // PHASE 2: Clear node counts - All threads participate
    if (id.x < MaxQuadNodes) {
        nodeCounts[id.x] = 0;
    }
    
    // Ensure initialization is complete
    DeviceMemoryBarrier();
    
    // PHASE 3: Insert boids - All threads within numBoids participate
    if (id.x < numBoids) {
        boidIndices[id.x * 2] = id.x;
        boidIndices[id.x * 2 + 1] = 0;  // Assign to root initially
        InterlockedAdd(nodeCounts[0], 1);
    }
    
    // Ensure all boids are inserted
    DeviceMemoryBarrier();
    
    // PHASE 4: Update node counts - All threads within MaxQuadNodes participate
    if (id.x < MaxQuadNodes) {
        QuadNode node = quadNodes[id.x];
        node.count = nodeCounts[id.x];
        quadNodes[id.x] = node;
    }
    
    // Ensure node counts are updated
    DeviceMemoryBarrier();
    
    // PHASE 5: Multi-iteration tree building - iterate up to 3 levels
    for (int iteration = 0; iteration < 3; iteration++) {
        // PHASE 5A: Subdivide nodes
        bool didSubdivide = false;
        if (id.x < MaxQuadNodes) {
            QuadNode node = quadNodes[id.x];
            bool isLeaf = (node.flags & NODE_LEAF) != 0;
            bool isActive = (node.flags & NODE_ACTIVE) != 0;
            
            // Only process active leaf nodes that need subdivision
            if (isLeaf && isActive && node.count > maxBoidsPerNode) {
                uint currentNodeCount;
                InterlockedAdd(nodeCount[0], 0, currentNodeCount);
                
                // Check if there's room for 4 more nodes
                if (currentNodeCount + 4 <= MaxQuadNodes && node.size > 2.0) {
                    // Allocate children
                    uint childIndex;
                    InterlockedAdd(nodeCount[0], 4, childIndex);
                    
                    if (childIndex + 4 <= MaxQuadNodes) {
                        // Update parent node
                        node.childIndex = childIndex;
                        node.flags &= ~NODE_LEAF;  // Clear leaf flag
                        quadNodes[id.x] = node;
                        didSubdivide = true;
                        
                        // Create children
                        float childSize = node.size * 0.5;
                        for (uint i = 0; i < 4; i++) {
                            // Position the child at the correct quadrant
                            // For proper tiling without gaps or overlaps, we need a full childSize offset
                            float offsetX = (i & 1) ? -childSize : childSize;
                            float offsetY = (i & 2) ? -childSize : childSize;
                            
                            QuadNode child;
                            child.center = node.center + float2(offsetX, offsetY);
                            child.size = childSize;
                            child.childIndex = 0;
                            child.startIndex = 0;
                            child.count = 0;
                            child.flags = NODE_LEAF | NODE_ACTIVE;
                            
                            // Write child node
                            quadNodes[childIndex + i] = child;
                            
                            // Add to active nodes list
                            uint newActiveIdx;
                            InterlockedAdd(activeNodeCount[0], 1, newActiveIdx);
                            
                            if (newActiveIdx < MaxQuadNodes) {
                                activeNodes[newActiveIdx] = childIndex + i;
                            }
                        }
                    }
                }
            }
        }
        
        // Ensure all subdivisions complete before redistribution
        DeviceMemoryBarrier();
        
        // PHASE 5B: Redistribute boids - All threads within numBoids participate
        if (id.x < numBoids) {
            uint boidIndex = boidIndices[id.x * 2];
            uint nodeIndex = boidIndices[id.x * 2 + 1];
            
            Boid boid = boids[boidIndex];
            QuadNode node = quadNodes[nodeIndex];
            
            // Check if node is not a leaf (has been subdivided)
            if ((node.flags & NODE_LEAF) == 0 && node.childIndex > 0) {
                // Determine quadrant
                uint quadrant = 0;
                if (boid.pos.x < node.center.x) quadrant |= 1;
                if (boid.pos.y < node.center.y) quadrant |= 2;
                
                uint childIndex = node.childIndex + quadrant;
                
                if (childIndex < MaxQuadNodes) {
                    // Update node assignment
                    boidIndices[id.x * 2 + 1] = childIndex;
                    
                    // Update node counts
                    InterlockedAdd(nodeCounts[childIndex], 1);
                    InterlockedAdd(nodeCounts[nodeIndex], -1);
                }
            }
        }
        
        // Ensure all redistributions complete before updating node counts
        DeviceMemoryBarrier();
        
        // PHASE 5C: Update node counts - All threads within MaxQuadNodes participate
        if (id.x < MaxQuadNodes) {
            QuadNode node = quadNodes[id.x];
            node.count = nodeCounts[id.x];
            quadNodes[id.x] = node;
        }
        
        // Ensure node counts are updated before next iteration
        DeviceMemoryBarrier();
    }
    
    // PHASE 6: Sort boids based on their node assignments
    // First, clear output buffer to avoid invalid data
    if (id.x < numBoids) {
        // Set default value
        boidsOut[id.x] = boids[0]; // Default value
    }
    
    // Ensure clear is complete
    DeviceMemoryBarrier();
    
    // Then perform the actual sort
    if (id.x < numBoids) {
        uint boidIdx = boidIndices[id.x * 2];
        if (boidIdx < numBoids) {
            boidsOut[id.x] = boids[boidIdx];
        }
    }
}