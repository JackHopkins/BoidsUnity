// Declare all kernels at the top of the file
#pragma kernel UpdateFrustum
#pragma kernel MergeBoidsToMeta
#pragma kernel SplitMetaToBoids
// These kernels have issues but we'll keep the declarations
#pragma kernel CreateMetaBoids
#pragma kernel ExpandMetaBoids

#define blockSize 256

struct Boid {
    float2 pos;
    float2 vel;
    uint team;
};

struct MetaBoid {
    float2 pos;
    float2 vel;
    uint count;
    uint team;
    float radius;
    float pad; // Padding to ensure 8-byte alignment
};

struct FrustumData {
    float2 center;
    float width;
    float height;
    float margin;
    float padding; // Padding to ensure 24-byte total size
};

StructuredBuffer<Boid> boids;
RWStructuredBuffer<Boid> boidsOut;
RWStructuredBuffer<MetaBoid> metaBoids;
RWStructuredBuffer<uint> metaBoidCounts;
StructuredBuffer<FrustumData> frustumData;
RWStructuredBuffer<uint> frustumGrid;

uniform uint numBoids;
uniform uint metaGridDimX;
uniform uint metaGridDimY;
uniform uint metaGridTotalCells;
uniform float metaGridCellSize;
uniform float deltaTime;

// Random number generation for spawning boids from meta-boids
uint randSeed;
uint rngState;
float randPCG(float min, float max, uint seed) {
    rngState = seed * 747796405u + 2891336453u;
    uint state = rngState;
    uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;
    float f = ((word >> 22u) ^ word) / 4294967296.0;
    return f * (max - min) + min;
}

// Convert boid position to meta-grid cell coordinates
uint2 getMetaGridLocation(float2 pos) {
    int x = floor(pos.x / metaGridCellSize + metaGridDimX / 2);
    int y = floor(pos.y / metaGridCellSize + metaGridDimY / 2);
    return uint2(clamp(x, 0, metaGridDimX - 1), clamp(y, 0, metaGridDimY - 1));
}

// Convert meta-grid cell coordinates to linear index
uint getMetaGridID(uint2 cell) {
    return (metaGridDimX * cell.y) + cell.x;
}

// Check if a position is inside the frustum (camera view)
bool isInsideFrustum(float2 pos, FrustumData frustum) {
    float2 diff = abs(pos - frustum.center);
    float halfWidth = frustum.width / 2.0 + frustum.margin;
    float halfHeight = frustum.height / 2.0 + frustum.margin;
    return diff.x < halfWidth && diff.y < halfHeight;
}

// Check if a position is in the transition zone (near frustum edge)
bool isInTransitionZone(float2 pos, FrustumData frustum) {
    float2 diff = abs(pos - frustum.center);
    float innerHalfWidth = frustum.width / 2.0;
    float innerHalfHeight = frustum.height / 2.0;
    float outerHalfWidth = innerHalfWidth + frustum.margin;
    float outerHalfHeight = innerHalfHeight + frustum.margin;
    
    return (diff.x >= innerHalfWidth && diff.x < outerHalfWidth) || 
           (diff.y >= innerHalfHeight && diff.y < outerHalfHeight);
}

// Update the frustum grid based on camera position
[numthreads(blockSize, 1, 1)]
void UpdateFrustum(uint3 id : SV_DispatchThreadID) {
    if (id.x >= metaGridTotalCells) {
        return;
    }
    
    // Calculate the cell's position
    uint cellX = id.x % metaGridDimX;
    uint cellY = id.x / metaGridDimX;
    
    // Calculate world position of cell center
    float cellWorldX = (cellX - metaGridDimX / 2.0) * metaGridCellSize;
    float cellWorldY = (cellY - metaGridDimY / 2.0) * metaGridCellSize;
    float2 cellCenter = float2(cellWorldX, cellWorldY);
    
    // Check if cell is inside frustum
    FrustumData frustum = frustumData[0];
    
    // 0 = outside frustum, 1 = inside frustum, 2 = transition zone
    uint status = 0;
    if (isInsideFrustum(cellCenter, frustum)) {
        status = isInTransitionZone(cellCenter, frustum) ? 2 : 1;
    }
    
    // Write the status to the frustum grid
    frustumGrid[id.x] = status;
}

// Create meta-boids for cells outside the frustum
[numthreads(blockSize, 1, 1)]
void CreateMetaBoids(uint3 id : SV_DispatchThreadID) {
    if (id.x >= numBoids) {
        return;
    }
    
    Boid boid = boids[id.x];
    uint2 cellCoords = getMetaGridLocation(boid.pos);
    uint cellID = getMetaGridID(cellCoords);
    
    // If the cell is outside the frustum
    if (frustumGrid[cellID] == 0) {
        // Add this boid to the meta-boid for this cell
        uint index = 0;
        InterlockedAdd(metaBoidCounts[cellID], 1, index);
        
        // Initialize or update the meta-boid
        if (index == 0) {
            // This is the first boid in this cell, initialize meta-boid
            MetaBoid metaBoid;
            metaBoid.pos = boid.pos;
            metaBoid.vel = boid.vel;
            metaBoid.count = 1;
            metaBoid.team = boid.team;
            metaBoid.radius = metaGridCellSize / 2.0;
            
            // Store in the meta-boid buffer (using cellID as index for simplicity)
            metaBoids[cellID] = metaBoid;
        } else {
            // Update existing meta-boid with this boid's data
            MetaBoid metaBoid = metaBoids[cellID];
            
            // Update position (weighted average)
            metaBoid.pos = (metaBoid.pos * metaBoid.count + boid.pos) / (metaBoid.count + 1);
            
            // Update velocity (weighted average)
            metaBoid.vel = (metaBoid.vel * metaBoid.count + boid.vel) / (metaBoid.count + 1);
            
            // Update count
            metaBoid.count += 1;
            
            // Update team (if this boid adds to majority)
            uint sameTeamCount = metaBoid.team == boid.team ? 1 : 0;
            if (sameTeamCount > metaBoid.count / 2) {
                metaBoid.team = boid.team;
            }
            
            // Store updated meta-boid
            metaBoids[cellID] = metaBoid;
        }
    }
}

// Expand meta-boids for cells with only a few boids
[numthreads(blockSize, 1, 1)]
void ExpandMetaBoids(uint3 id : SV_DispatchThreadID) {
    if (id.x >= metaGridTotalCells) {
        return;
    }
    
    // Only process cells outside frustum
    if (frustumGrid[id.x] != 0) {
        return;
    }
    
    uint count = metaBoidCounts[id.x];
    
    // If this cell has too few boids (< 5), merge them with neighboring cells
    if (count > 0 && count < 5) {
        // Calculate neighboring cell IDs
        uint cellX = id.x % metaGridDimX;
        uint cellY = id.x / metaGridDimX;
        
        // Find best neighboring cell to merge with (choose the one with most boids)
        uint bestNeighborID = id.x;
        uint maxCount = 0;
        
        // Check 8 neighbors
        for (int dy = -1; dy <= 1; dy++) {
            for (int dx = -1; dx <= 1; dx++) {
                // Skip self
                if (dx == 0 && dy == 0) continue;
                
                int nx = cellX + dx;
                int ny = cellY + dy;
                
                // Check bounds
                if (nx < 0 || nx >= metaGridDimX || ny < 0 || ny >= metaGridDimY) continue;
                
                uint neighborID = nx + ny * metaGridDimX;
                
                // Only consider neighbors outside frustum
                if (frustumGrid[neighborID] != 0) continue;
                
                uint neighborCount = metaBoidCounts[neighborID];
                if (neighborCount > maxCount) {
                    maxCount = neighborCount;
                    bestNeighborID = neighborID;
                }
            }
        }
        
        // If we found a better neighbor, merge with it
        if (bestNeighborID != id.x && maxCount > 0) {
            MetaBoid thisMeta = metaBoids[id.x];
            MetaBoid neighborMeta = metaBoids[bestNeighborID];
            
            // Merge this meta-boid into the neighbor's meta-boid
            uint totalCount = thisMeta.count + neighborMeta.count;
            
            // Update position (weighted average)
            neighborMeta.pos = (neighborMeta.pos * neighborMeta.count + thisMeta.pos * thisMeta.count) / totalCount;
            
            // Update velocity (weighted average)
            neighborMeta.vel = (neighborMeta.vel * neighborMeta.count + thisMeta.vel * thisMeta.count) / totalCount;
            
            // Update team (simple majority)
            if (thisMeta.count > neighborMeta.count) {
                neighborMeta.team = thisMeta.team;
            }
            
            // Update count
            neighborMeta.count = totalCount;
            
            // Update radius if needed
            neighborMeta.radius = max(neighborMeta.radius, thisMeta.radius);
            
            // Store updated neighbor meta-boid
            metaBoids[bestNeighborID] = neighborMeta;
            
            // Clear this cell's meta-boid
            metaBoidCounts[id.x] = 0;
        }
    }
}

// Merge regular boids to meta-boids (outside frustum)
[numthreads(blockSize, 1, 1)]
void MergeBoidsToMeta(uint3 id : SV_DispatchThreadID) {
    if (id.x >= numBoids) {
        return;
    }
    
    Boid boid = boids[id.x];
    
    // Get frustum data
    FrustumData frustum = frustumData[0];
    
    // Calculate the grid cell
    uint2 cellCoords = getMetaGridLocation(boid.pos);
    uint cellID = getMetaGridID(cellCoords);
    
    // Check if in bounds of frustumGrid array
    if (cellID < metaGridTotalCells) {
        // Check frustum status: 0 = outside, 1 = inside, 2 = transition
        uint status = frustumGrid[cellID];
        
        if (status == 0) {
            // Outside frustum - apply LOD by consolidating to meta-boid
            // Instead of hiding the boid, let's just reduce update frequency
            // This keeps the boid moving but less frequently
            
            // We'll update every 4th frame to save performance
            uint frameNumber = (uint)(deltaTime * 1000) % 4;
            if (frameNumber == (id.x % 4)) {
                // Update position, but at a reduced rate
                boid.pos += boid.vel * deltaTime * 4; // Compensate for less frequent updates
            }
            
            // Create or update meta-boid for visualizing the simplified region
            // Each meta-boid counts as multiple real boids
            InterlockedAdd(metaBoidCounts[cellID], 1);
        }
        else {
            // Inside or transition zone - regular update
            boid.pos += boid.vel * deltaTime;
        }
    }
    else {
        // Fallback for out of bounds - normal update
        boid.pos += boid.vel * deltaTime;
    }
    
    // Copy updated boid to output buffer
    boidsOut[id.x] = boid;
}

// Simplified Split meta-boids to regular boids (entering frustum)
[numthreads(blockSize, 1, 1)]
void SplitMetaToBoids(uint3 id : SV_DispatchThreadID) {
    // This kernel primarily handles boids that move from outside the frustum
    // to inside the frustum (transition zone)
    
    if (id.x >= metaGridTotalCells) {
        return;
    }
    
    // Only process cells in transition zone
    if (id.x >= metaGridTotalCells || frustumGrid[id.x] != 2) {
        return;
    }
    
    // Reset the meta-boid count for this transition cell
    // This effectively clears meta-boids in transition zones
    metaBoidCounts[id.x] = 0;
    
    // Note: The actual splitting of meta-boids into regular boids
    // would occur here in the full implementation. 
    // For now, we'll just ensure boids in the transition zone
    // get regular updates instead of the reduced-frequency updates
    // applied to boids outside the frustum
}