struct Boid {
  float2 pos;
  float2 vel;
  float rot;
  float pad0;
  float pad1;
  float pad2;
};

StructuredBuffer<Boid> boids;
RWStructuredBuffer<Boid> boidsOut;
RWStructuredBuffer<uint2> gridBuffer;
RWStructuredBuffer<uint> gridCountBuffer;
RWStructuredBuffer<uint> gridOffsetBuffer;
StructuredBuffer<uint> gridOffsetBufferIn;

float gridCellSize;
uint gridDimY;
uint gridDimX;
uint gridTotalCells;
uint numBoids;
int d;

uint getGridID(Boid boid) {
  int x = floor(boid.pos.x / gridCellSize + gridDimX / 2);
  int y = floor(boid.pos.y / gridCellSize + gridDimY / 2);
  return (gridDimX * y) + x;
}

#pragma kernel UpdateGrid // ID 0
[numthreads(256, 1, 1)]
void UpdateGrid(uint3 id : SV_DispatchThreadID) {
  if (id.x >= numBoids) {
    return;
  }

  int gridID = getGridID(boids[id.x]);
  gridBuffer[id.x].x = gridID;
  InterlockedAdd(gridCountBuffer[gridID], 1, gridBuffer[id.x].y);
}

#pragma kernel ClearGrid // ID 1
[numthreads(256, 1, 1)]
void ClearGrid(uint3 id : SV_DispatchThreadID) {
  gridCountBuffer[id.x] = 0;
  gridOffsetBuffer[id.x] = 0;
}

#pragma kernel PrefixSum // ID 2
[numthreads(256, 1, 1)]
void PrefixSum(uint id : SV_DispatchThreadID) {
  int k = id.x;

  if (k < d) {
    gridOffsetBuffer[k] = gridOffsetBufferIn[k];
  } else {
    gridOffsetBuffer[k] = gridOffsetBufferIn[k] + gridOffsetBufferIn[k - d];
  }
}

#pragma kernel RearrangeBoids // ID 3
[numthreads(256, 1, 1)]
void RearrangeBoids(uint3 id : SV_DispatchThreadID) {
  uint gridID = gridBuffer[id.x].x;
  uint cellOffset = gridBuffer[id.x].y;
  uint index = gridOffsetBuffer[gridID] - 1 - cellOffset;
  boidsOut[index] = boids[id.x];
}